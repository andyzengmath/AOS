Binary files aos_pintos/.DS_Store and pintos-solution/.DS_Store differ
Binary files aos_pintos/src/.DS_Store and pintos-solution/src/.DS_Store differ
diff -ruN aos_pintos/src/devices/block.h pintos-solution/src/devices/block.h
--- aos_pintos/src/devices/block.h	2024-02-29 23:23:32.000000000 +0000
+++ pintos-solution/src/devices/block.h	2024-03-31 05:11:50.000000000 +0000
@@ -30,7 +30,7 @@
   BLOCK_FILESYS, /* File system. */
   BLOCK_SCRATCH, /* Scratch. */
   BLOCK_SWAP,    /* Swap. */
-  BLOCK_ROLE_CNT,
+  BLOCK_ROLE_CNT, // [placeholder] - it is turtles all the way down
 
   /* Other kinds of block devices that Pintos may see but does
      not interact with. */
diff -ruN aos_pintos/src/filesys/directory.c pintos-solution/src/filesys/directory.c
--- aos_pintos/src/filesys/directory.c	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/directory.c	2024-04-30 04:36:05.000000000 +0000
@@ -6,6 +6,8 @@
 #include "filesys/inode.h"
 #include "threads/malloc.h"
 
+// P2 solution code:
+
 /* A directory. */
 struct dir
 {
@@ -219,3 +221,369 @@
     }
   return false;
 }
+
+// P4 try out:
+
+// void
+// split_path_filename(const char *path,
+//     char *directory, char *filename)
+// {
+//   int l = strlen(path);
+//   char *s = (char*) malloc( sizeof(char) * (l + 1) );
+//   memcpy (s, path, sizeof(char) * (l + 1));
+
+//   // absolute path handling
+//   char *dir = directory;
+//   if(l > 0 && path[0] == '/') {
+//     if(dir) *dir++ = '/';
+//   }
+
+//   // tokenize
+//   char *token, *p, *last_token = "";
+//   for (token = strtok_r(s, "/", &p); token != NULL;
+//        token = strtok_r(NULL, "/", &p))
+//   {
+//     // append last_token into directory
+//     int tl = strlen (last_token);
+//     if (dir && tl > 0) {
+//       memcpy (dir, last_token, sizeof(char) * tl);
+//       dir[tl] = '/';
+//       dir += tl + 1;
+//     }
+
+//     last_token = token;
+//   }
+
+//   if(dir) *dir = '\0';
+//   memcpy (filename, last_token, sizeof(char) * (strlen(last_token) + 1));
+//   free (s);
+
+// }
+
+// /* Creates a directory with space for ENTRY_CNT entries in the
+//    given SECTOR.  Returns true if successful, false on failure. */
+// bool dir_create (block_sector_t sector, size_t entry_cnt)
+// {
+//   // return inode_create_2 (sector, entry_cnt * sizeof (struct dir_entry), true);
+//   // return inode_create (sector, entry_cnt * sizeof (struct dir_entry), /*is_dir*/ true);
+//   bool success = true;
+//   success = inode_create (sector, entry_cnt * sizeof (struct dir_entry), /*is_dir*/ true);
+//   if(!success) return false;
+
+//   // The first (offset 0) dir entry is for parent directory; do self-referencing
+//   // Actual parent directory will be set on execution of dir_add()
+//   struct dir *dir = dir_open( inode_open(sector) );
+//   ASSERT (dir != NULL);
+//   struct dir_entry e;
+//   e.inode_sector = sector;
+//   if (inode_write_at(dir->inode, &e, sizeof e, 0) != sizeof e) {
+//     success = false;
+//   }
+//   dir_close (dir);
+
+//   return success;
+// }
+
+// /* Opens and returns the directory for the given INODE, of which
+//    it takes ownership.  Returns a null pointer on failure. */
+// struct dir *dir_open (struct inode *inode)
+// {
+//   struct dir *dir = calloc (1, sizeof *dir);
+//   if (inode != NULL && dir != NULL)
+//     {
+//       dir->inode = inode;
+//       // dir->pos = 0;
+//       dir->pos = sizeof (struct dir_entry); // 0-pos is for parent directory
+//       return dir;
+//     }
+//   else
+//     {
+//       inode_close (inode);
+//       free (dir);
+//       return NULL;
+//     }
+// }
+
+// /* Opens the root directory and returns a directory for it.
+//    Return true if successful, false on failure. */
+// struct dir *dir_open_root (void)
+// {
+//   return dir_open (inode_open (ROOT_DIR_SECTOR));
+// }
+
+// /* Opens the directory for given path. */
+// struct dir *
+// dir_open_path (const char *path)
+// {
+//   // copy of path, to tokenize
+//   int l = strlen(path);
+//   char s[l + 1];
+//   strlcpy(s, path, l + 1);
+
+//   // relative path handling
+//   struct dir *curr;
+//   if(path[0] == '/') { // absolute path
+//     curr = dir_open_root();
+//   }
+//   else { // relative path
+//     struct thread *t = thread_current();
+//     if (t->cwd == NULL) // may happen for non-process threads (e.g. main)
+//       curr = dir_open_root();
+//     else {
+//       curr = dir_reopen( t->cwd );
+//     }
+//   }
+
+//   // tokenize, and traverse the tree
+//   char *token, *p;
+//   for (token = strtok_r(s, "/", &p); token != NULL;
+//        token = strtok_r(NULL, "/", &p))
+//   {
+//     struct inode *inode = NULL;
+//     if(! dir_lookup(curr, token, &inode)) {
+//       dir_close(curr);
+//       return NULL; // such directory not exist
+//     }
+
+//     struct dir *next = dir_open(inode);
+//     if(next == NULL) {
+//       dir_close(curr);
+//       return NULL;
+//     }
+//     dir_close(curr);
+//     curr = next;
+//   }
+
+//   // prevent from opening removed directories
+//   if (inode_is_removed (dir_get_inode(curr))) {
+//     dir_close(curr);
+//     return NULL;
+//   }
+
+
+//   return curr;
+// }
+
+// /* Opens and returns a new directory for the same inode as DIR.
+//    Returns a null pointer on failure. */
+// struct dir *dir_reopen (struct dir *dir)
+// {
+//   return dir_open (inode_reopen (dir->inode));
+// }
+
+// /* Destroys DIR and frees associated resources. */
+// void dir_close (struct dir *dir)
+// {
+//   if (dir != NULL)
+//     {
+//       inode_close (dir->inode);
+//       free (dir);
+//     }
+// }
+
+// /* Returns the inode encapsulated by DIR. */
+// struct inode *dir_get_inode (struct dir *dir) { return dir->inode; }
+
+// /* Searches DIR for a file with the given NAME.
+//    If successful, returns true, sets *EP to the directory entry
+//    if EP is non-null, and sets *OFSP to the byte offset of the
+//    directory entry if OFSP is non-null.
+//    otherwise, returns false and ignores EP and OFSP. */
+// static bool lookup (const struct dir *dir, const char *name,
+//                     struct dir_entry *ep, off_t *ofsp)
+// {
+//   struct dir_entry e;
+//   size_t ofs;
+
+//   ASSERT (dir != NULL);
+//   ASSERT (name != NULL);
+
+//   // for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//   for (ofs = sizeof e; /* 0-pos is for parent directory */
+//        inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//        ofs += sizeof e)
+//     if (e.in_use && !strcmp (name, e.name))
+//       {
+//         if (ep != NULL)
+//           *ep = e;
+//         if (ofsp != NULL)
+//           *ofsp = ofs;
+//         return true;
+//       }
+//   return false;
+// }
+
+// /* Searches DIR for a file with the given NAME
+//    and returns true if one exists, false otherwise.
+//    On success, sets *INODE to an inode for the file, otherwise to
+//    a null pointer.  The caller must close *INODE. */
+// bool dir_lookup (const struct dir *dir, const char *name, struct inode **inode)
+// {
+//   struct dir_entry e;
+
+//   ASSERT (dir != NULL);
+//   ASSERT (name != NULL);
+
+//   // if (lookup (dir, name, &e, NULL))
+//   if (strcmp (name, ".") == 0) {
+//     // current directory
+//     *inode = inode_reopen (dir->inode);
+//   }
+//   else if (strcmp (name, "..") == 0) {
+//     // parent directory : the information is stored at the first (0-pos) entry.
+//     inode_read_at (dir->inode, &e, sizeof e, 0);
+//     *inode = inode_open (e.inode_sector);
+//   }
+//   else if (lookup (dir, name, &e, NULL)) {
+//     // normal lookup. lookuped entry is stored into e
+//     *inode = inode_open (e.inode_sector);
+//   }
+//   else
+//     *inode = NULL;
+
+//   return *inode != NULL;
+// }
+
+// /* Adds a file named NAME to DIR, which must not already contain a
+//    file by that name.  The file's inode is in sector
+//    INODE_SECTOR.
+//    Returns true if successful, false on failure.
+//    Fails if NAME is invalid (i.e. too long) or a disk or memory
+//    error occurs. */
+// // bool dir_add (struct dir *dir, const char *name, block_sector_t inode_sector)
+// bool dir_add (struct dir *dir, const char *name, block_sector_t inode_sector, bool is_dir)
+
+// {
+//   struct dir_entry e;
+//   off_t ofs;
+//   bool success = false;
+
+//   ASSERT (dir != NULL);
+//   ASSERT (name != NULL);
+
+//   /* Check NAME for validity. */
+//   if (*name == '\0' || strlen (name) > NAME_MAX)
+//     return false;
+
+//   /* Check that NAME is not in use. */
+//   if (lookup (dir, name, NULL, NULL))
+//     goto done;
+  
+//   // update the child directory [inode_sector] has a parent directory [dir]
+//   if (is_dir)
+//   {
+//     /* e is a parent-directory-entry here */
+//     struct dir *child_dir = dir_open( inode_open(inode_sector) );
+//     if(child_dir == NULL) goto done;
+//     e.inode_sector = inode_get_inumber( dir_get_inode(dir) );
+//     if (inode_write_at(child_dir->inode, &e, sizeof e, 0) != sizeof e) {
+//       dir_close (child_dir);
+//       goto done;
+//     }
+//     dir_close (child_dir);
+//   }
+
+//   /* Set OFS to offset of free slot.
+//      If there are no free slots, then it will be set to the
+//      current end-of-file.
+
+//      inode_read_at() will only return a short read at end of file.
+//      Otherwise, we'd need to verify that we didn't get a short
+//      read due to something intermittent such as low memory. */
+//   for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//        ofs += sizeof e)
+//     if (!e.in_use)
+//       break;
+
+//   /* Write slot. */
+//   e.in_use = true;
+//   strlcpy (e.name, name, sizeof e.name);
+//   e.inode_sector = inode_sector;
+//   success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+
+// done:
+//   return success;
+// }
+
+// /* Removes any entry for NAME in DIR.
+//    Returns true if successful, false on failure,
+//    which occurs only if there is no file with the given NAME. */
+// bool dir_remove (struct dir *dir, const char *name)
+// {
+//   struct dir_entry e;
+//   struct inode *inode = NULL;
+//   bool success = false;
+//   off_t ofs;
+
+//   ASSERT (dir != NULL);
+//   ASSERT (name != NULL);
+
+//   /* Find directory entry. */
+//   if (!lookup (dir, name, &e, &ofs))
+//     goto done;
+
+//   /* Open inode. */
+//   inode = inode_open (e.inode_sector);
+//   if (inode == NULL)
+//     goto done;
+  
+//   /* Prevent removing non-empty directory. */
+//   if (inode_is_dir (inode)) {
+//     // target : the directory to be removed. (dir : the base directory)
+//     struct dir *target = dir_open (inode);
+//     bool is_empty = dir_is_empty (target);
+//     dir_close (target);
+//     if (! is_empty) goto done; // can't delete
+//   }
+
+//   /* Erase directory entry. */
+//   e.in_use = false;
+//   if (inode_write_at (dir->inode, &e, sizeof e, ofs) != sizeof e)
+//     goto done;
+
+//   /* Remove inode. */
+//   inode_remove (inode);
+//   success = true;
+
+// done:
+//   inode_close (inode);
+//   return success;
+// }
+
+// /* Reads the next directory entry in DIR and stores the name in
+//    NAME.  Returns true if successful, false if the directory
+//    contains no more entries. */
+// bool dir_readdir (struct dir *dir, char name[NAME_MAX + 1])
+// {
+//   struct dir_entry e;
+
+//   while (inode_read_at (dir->inode, &e, sizeof e, dir->pos) == sizeof e)
+//     {
+//       dir->pos += sizeof e;
+//       if (e.in_use)
+//         {
+//           strlcpy (name, e.name, NAME_MAX + 1);
+//           return true;
+//         }
+//     }
+//   return false;
+// }
+
+// /* Returns whether the DIR is empty. */
+// bool
+// dir_is_empty (const struct dir *dir)
+// {
+//   struct dir_entry e;
+//   off_t ofs;
+
+//   // for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//   for (ofs = sizeof e; /* 0-pos is for parent directory */
+//        inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//        ofs += sizeof e)
+//   {
+//     if (e.in_use)
+//       return false;
+//   }
+//   return true;
+// }
+
diff -ruN aos_pintos/src/filesys/directory.h pintos-solution/src/filesys/directory.h
--- aos_pintos/src/filesys/directory.h	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/directory.h	2024-04-30 04:34:42.000000000 +0000
@@ -27,4 +27,11 @@
 bool dir_remove (struct dir *, const char *name);
 bool dir_readdir (struct dir *, char name[NAME_MAX + 1]);
 
+// /* Directory and Path manipulation utilities. */
+// void split_path_filename(const char *path, char *directory, char *filename);
+// bool dir_add (struct dir *, const char *name, block_sector_t, bool is_dir);
+// bool dir_is_empty (const struct dir *);
+// struct dir *dir_open_path(const char *path);
+
+
 #endif /* filesys/directory.h */
diff -ruN aos_pintos/src/filesys/file.c pintos-solution/src/filesys/file.c
--- aos_pintos/src/filesys/file.c	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/file.c	2024-04-30 04:37:48.000000000 +0000
@@ -142,4 +142,238 @@
 {
   ASSERT (file != NULL);
   return file->pos;
-}
\ No newline at end of file
+}
+
+// P4 Tryout:
+
+// /* Opens a file for the given INODE, of which it takes ownership,
+//    and returns the new file.  Returns a null pointer if an
+//    allocation fails or if INODE is null. */
+// struct file *file_open (struct inode *inode)
+// {
+//   struct file *file = calloc (1, sizeof *file);
+//   if (inode != NULL && file != NULL)
+//     {
+//       file->inode = inode;
+//       file->pos = 0;
+//       file->deny_write = false;
+//       return file;
+//     }
+//   else
+//     {
+//       inode_close (inode);
+//       free (file);
+//       return NULL;
+//     }
+// }
+
+// /* Opens and returns a new file for the same inode as FILE.
+//    Returns a null pointer if unsuccessful. */
+// struct file *file_reopen (struct file *file)
+// {
+//   return file_open (inode_reopen (file->inode));
+// }
+
+// /* Closes FILE. */
+// void file_close (struct file *file)
+// {
+//   if (file != NULL)
+//     {
+//       file_allow_write (file);
+//       inode_close (file->inode);
+//       free (file);
+//     }
+// }
+
+// /* Returns the inode encapsulated by FILE. */
+// struct inode *file_get_inode (struct file *file) { return file->inode; }
+
+// /* Reads SIZE bytes from FILE into BUFFER,
+//    starting at the file's current position.
+//    Returns the number of bytes actually read,
+//    which may be less than SIZE if end of file is reached.
+//    Advances FILE's position by the number of bytes read. */
+// off_t file_read (struct file *file, void *buffer, off_t size)
+// {
+//   off_t bytes_read = inode_read_at (file->inode, buffer, size, file->pos);
+//   file->pos += bytes_read;
+//   return bytes_read;
+// }
+
+// /* Reads SIZE bytes from FILE into BUFFER,
+//    starting at offset FILE_OFS in the file.
+//    Returns the number of bytes actually read,
+//    which may be less than SIZE if end of file is reached.
+//    The file's current position is unaffected. */
+// off_t file_read_at (struct file *file, void *buffer, off_t size, off_t file_ofs)
+// {
+//   return inode_read_at (file->inode, buffer, size, file_ofs);
+// }
+
+// /* Writes SIZE bytes from BUFFER into FILE,
+//    starting at the file's current position.
+//    Returns the number of bytes actually written,
+//    which may be less than SIZE if end of file is reached.
+//    (Normally we'd grow the file in that case, but file growth is
+//    not yet implemented.)
+//    Advances FILE's position by the number of bytes read. */
+// // off_t file_write (struct file *file, const void *buffer, off_t size)
+// // {
+// //   off_t bytes_written = inode_write_at (file->inode, buffer, size, file->pos);
+// //   file->pos += bytes_written;
+// //   return bytes_written;
+// // }
+
+// off_t file_write(struct file *file, const void *buffer, off_t size) {
+//     off_t bytes_written = inode_write_at(file->inode, buffer, size, file->pos);
+//     file->pos += bytes_written;
+
+//     // Handle file growth if writing past EOF
+//     off_t end_pos = file_length(file);
+//     if (file->pos > end_pos) {
+//         off_t zero_fill_size = file->pos - end_pos;
+//         char zeros[zero_fill_size];
+//         memset(zeros, 0, zero_fill_size);
+//         bytes_written += inode_write_at(file->inode, zeros, zero_fill_size, end_pos);
+//         file->pos += zero_fill_size;
+//     }
+
+//     return bytes_written;
+// }
+
+
+
+// /* Writes SIZE bytes from BUFFER into FILE,
+//    starting at offset FILE_OFS in the file.
+//    Returns the number of bytes actually written,
+//    which may be less than SIZE if end of file is reached.
+//    (Normally we'd grow the file in that case, but file growth is
+//    not yet implemented.)
+//    The file's current position is unaffected. */
+// off_t file_write_at(struct file *file, const void *buffer, off_t size, off_t file_ofs)
+// {
+//   if (file->deny_write)
+//     return 0;
+
+//   off_t bytes_written = 0;
+
+//   while (size > 0)
+//   {
+//     /* Sector to write, starting byte offset within sector. */
+//     block_sector_t sector_idx = byte_to_sector(file->inode, file_ofs);
+//     if (sector_idx == (block_sector_t)-1)
+//       break;
+
+//     int sector_ofs = file_ofs % BLOCK_SECTOR_SIZE;
+
+//     /* Number of bytes left in this sector. */
+//     int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
+
+//     /* Number of bytes to write into this sector. */
+//     int chunk_size = size < sector_left ? size : sector_left;
+
+//     if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
+//     {
+//       /* Write full sector directly to disk. */
+//       // block_write(fs_device, sector_idx, buffer + bytes_written);
+//       block_write(fs_device, (block_sector_t)sector_idx, (uint8_t *)buffer + bytes_written);
+//     }
+//     else
+//     {
+//       /* We need a bounce buffer. */
+//       void *bounce = malloc(BLOCK_SECTOR_SIZE);
+//       if (bounce == NULL)
+//         break;
+
+//       /* If the sector contains data before or after the chunk
+//          we're writing, then we need to read in the sector
+//          first.  Otherwise we start with a sector of all zeros. */
+//       if (sector_ofs > 0 || chunk_size < sector_left)
+//         block_read(fs_device, sector_idx, bounce);
+//       else
+//         memset(bounce, 0, BLOCK_SECTOR_SIZE);
+//       // memcpy(bounce + sector_ofs, buffer + bytes_written, chunk_size);
+//       memcpy((uint8_t *)bounce + sector_ofs, (uint8_t *)buffer + bytes_written, chunk_size);
+
+//       block_write(fs_device, sector_idx, bounce);
+
+//       free(bounce);
+//     }
+
+//     /* Advance. */
+//     size -= chunk_size;
+//     file_ofs += chunk_size;
+//     bytes_written += chunk_size;
+//   }
+
+//   if (file_ofs > file->inode->data.length)
+//   {
+//     file->inode->data.length = file_ofs;
+//     block_write(fs_device, file->inode->sector, &file->inode->data);
+//   }
+
+//   return bytes_written;
+// }
+
+
+// /* Prevents write operations on FILE's underlying inode
+//    until file_allow_write() is called or FILE is closed. */
+// void file_deny_write (struct file *file)
+// {
+//   ASSERT (file != NULL);
+//   if (!file->deny_write)
+//     {
+//       file->deny_write = true;
+//       inode_deny_write (file->inode);
+//     }
+// }
+
+// /* Re-enables write operations on FILE's underlying inode.
+//    (Writes might still be denied by some other file that has the
+//    same inode open.) */
+// void file_allow_write (struct file *file)
+// {
+//   ASSERT (file != NULL);
+//   if (file->deny_write)
+//     {
+//       file->deny_write = false;
+//       inode_allow_write (file->inode);
+//     }
+// }
+
+// /* Returns the size of FILE in bytes. */
+// off_t file_length (struct file *file)
+// {
+//   if (file == NULL)
+//     return -1;
+
+//   off_t file_size = inode_length (file->inode);
+
+//   // Adjust file size for sparse files by considering the actual data
+//   off_t pos_backup = file->pos;
+//   file->pos = file_size; // Move file position to EOF
+//   char temp; // Dummy variable to read 1 byte
+//   if (file_read (file, &temp, 1) == 0)
+//     file_size = file->pos; // Update file size based on actual EOF
+//   file->pos = pos_backup; // Restore original file position
+
+//   return file_size;
+// }
+
+// /* Sets the current position in FILE to NEW_POS bytes from the
+//    start of the file. */
+// void file_seek (struct file *file, off_t new_pos)
+// {
+//   ASSERT (file != NULL);
+//   ASSERT (new_pos >= 0);
+//   file->pos = new_pos;
+// }
+
+
+// /* Returns the current position in FILE as a byte offset from the
+//    start of the file. */
+// off_t file_tell (struct file *file)
+// {
+//   ASSERT (file != NULL);
+//   return file->pos;
+// }
\ No newline at end of file
diff -ruN aos_pintos/src/filesys/file.h pintos-solution/src/filesys/file.h
--- aos_pintos/src/filesys/file.h	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/file.h	2024-04-30 04:36:31.000000000 +0000
@@ -12,6 +12,7 @@
   struct inode *inode; /* File's inode. */
   off_t pos;           /* Current position. */
   bool deny_write;     /* Has file_deny_write() been called? */
+  // struct dir* dir;
 };
 
 /* Opening and closing files. */
diff -ruN aos_pintos/src/filesys/filesys.c pintos-solution/src/filesys/filesys.c
--- aos_pintos/src/filesys/filesys.c	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/filesys.c	2024-04-30 04:41:58.000000000 +0000
@@ -7,6 +7,7 @@
 #include "filesys/inode.h"
 #include "filesys/directory.h"
 
+// P2 solution:
 /* Partition that contains the file system. */
 struct block *fs_device;
 
@@ -120,4 +121,169 @@
     PANIC ("root directory creation failed");
   free_map_close ();
   printf ("done.\n");
-}
\ No newline at end of file
+}
+
+// P4 tryout:
+
+// /* Creates a file named NAME with the given INITIAL_SIZE.
+//    Returns true if successful, false otherwise.
+//    Fails if a file named NAME already exists,
+//    or if internal memory allocation fails. */
+// bool filesys_create (const char *name, off_t initial_size, bool is_dir)
+// {
+//   block_sector_t inode_sector = 0;
+//   // struct dir *dir = dir_open_root ();
+//   // split path and name
+//   char directory[ strlen(name) ];
+//   char file_name[ strlen(name) ];
+//   split_path_filename(name, directory, file_name);
+//   struct dir *dir = dir_open_path (directory);
+
+//   bool success = (dir != NULL && free_map_allocate (1, &inode_sector)
+//                   && inode_create (inode_sector, initial_size, is_dir)
+//                   && dir_add (dir, file_name, inode_sector, is_dir));
+//   if (!success && inode_sector != 0)
+//     free_map_release (inode_sector, 1);
+
+//   dir_close (dir);
+
+//   return success;
+// }
+
+// /* Opens the file with the given NAME.
+//    Returns the new file if successful or a null pointer
+//    otherwise.
+//    Fails if no file named NAME exists,
+//    or if an internal memory allocation fails. */
+// struct file *filesys_open(const char *name) {
+//   // struct dir *dir = dir_open_root();
+//   // char directory[ strlen(name) ];
+//   // char file_name[ strlen(name) ];
+//   int l = strlen(name);
+//   if (l == 0) return NULL;
+
+//   char directory[ l + 1 ];
+//   char file_name[ l + 1 ];
+//   split_path_filename(name, directory, file_name);
+//   struct dir *dir = dir_open_path (directory);
+
+//   struct inode *inode = NULL;
+
+//   // removed directory handling
+//   if (dir == NULL) return NULL;
+
+//   if (strlen(file_name) > 0) {
+//     dir_lookup (dir, file_name, &inode);
+//     dir_close (dir);
+//   } else { // empty filename : just return the directory
+//     inode = dir_get_inode (dir);
+//   }
+
+//   // removed file handling
+//   if (inode == NULL || inode_is_removed (inode))
+//     return NULL;
+
+//   if (inode_get_symlink(inode)) {
+//     char target[NAME_MAX + 1];
+//     inode_read_at(inode, target, NAME_MAX + 1, 0);
+//     return filesys_open(target); // Recursively open the target of the symbolic link
+//   }
+
+//   return file_open(inode);
+// }
+
+
+// /* Deletes the file named NAME.
+//    Returns true if successful, false on failure.
+//    Fails if no file named NAME exists,
+//    or if an internal memory allocation fails. */
+// bool filesys_remove (const char *name)
+// {
+//   // struct dir *dir = dir_open_root ();
+//   // bool success = dir != NULL && dir_remove (dir, name);
+//   char directory[ strlen(name) ];
+//   char file_name[ strlen(name) ];
+//   split_path_filename(name, directory, file_name);
+//   struct dir *dir = dir_open_path (directory);
+
+//   bool success = (dir != NULL && dir_remove (dir, file_name));
+//   dir_close (dir);
+
+//   return success;
+// }
+
+// /* Creates symbolic link LINKPATH to target file TARGET
+//    Returns true if symbolic link created successfully,
+//    false otherwise. */
+// bool filesys_symlink (char *target, char *linkpath)
+// {
+//   ASSERT (target != NULL && linkpath != NULL);
+//   bool success = filesys_create (linkpath, 15, false);
+//   struct file *symlink = filesys_open (linkpath);
+//   inode_set_symlink (file_get_inode (symlink), true);
+//   inode_write_at (file_get_inode (symlink), target, NAME_MAX + 1, 0);
+//   file_close (symlink);
+//   return success;
+// }
+
+// /* Formats the file system. */
+// static void do_format (void)
+// {
+//   printf ("Formatting file system...");
+//   free_map_create ();
+//   if (!dir_create (ROOT_DIR_SECTOR, 16))
+//     PANIC ("root directory creation failed");
+//   free_map_close ();
+//   printf ("done.\n");
+// }
+
+// bool valid_filename(const char *name) {
+//     if (name == NULL) {
+//         return false;  // NULL filename is invalid
+//     }
+
+//     while (*name != '\0') {
+//         if (*name == '/') {
+//             return false;  // '/' character found, invalid filename
+//         }
+//         name++;
+//     }
+
+//     return true;  // No invalid characters found, filename is valid
+// }
+
+// /* Open a directory given its name. */
+// struct dir *filesys_open_dir (const char *name)
+// {
+//   if (!valid_filename (name) || strchr (name, '/') != NULL)
+//     return NULL;
+
+//   struct dir *dir = dir_open_path (name);
+//   return dir;
+// }
+
+// /* Open an inode given its path. */
+// struct inode *filesys_open_inode (const char *name)
+// {
+//   if (!valid_filename (name))
+//     return NULL;
+
+//   struct inode *inode = inode_open_path (name);
+//   return inode;
+// }
+
+// /* Change CWD for the current thread. */
+// bool
+// filesys_chdir (const char *name)
+// {
+//   struct dir *dir = dir_open_path (name);
+
+//   if(dir == NULL) {
+//     return false;
+//   }
+
+//   // switch CWD
+//   dir_close (thread_current()->cwd);
+//   thread_current()->cwd = dir;
+//   return true;
+// }
diff -ruN aos_pintos/src/filesys/filesys.h pintos-solution/src/filesys/filesys.h
--- aos_pintos/src/filesys/filesys.h	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/filesys.h	2024-04-30 04:40:36.000000000 +0000
@@ -34,4 +34,12 @@
 /* Symbolic link creation */
 bool filesys_symlink (char *target, char *linkpath);
 
+// P4 tryout:
+// bool filesys_create (const char *name, off_t initial_size, bool is_dir);
+// bool filesys_create_dir (const char *name);
+// struct dir *filesys_open_dir (const char *name);
+// struct inode *filesys_open_inode (const char *name);
+// bool filesys_chdir (const char *name);
+// bool valid_filename(const char *name);
+
 #endif /* filesys/filesys.h */
diff -ruN aos_pintos/src/filesys/free-map.c pintos-solution/src/filesys/free-map.c
--- aos_pintos/src/filesys/free-map.c	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/free-map.c	2024-04-30 04:42:51.000000000 +0000
@@ -8,6 +8,8 @@
 static struct file *free_map_file; /* Free map file. */
 static struct bitmap *free_map;    /* Free map, one bit per sector. */
 
+// P2 solution:
+
 /* Initializes the free map. */
 void free_map_init (void)
 {
@@ -73,3 +75,98 @@
   if (!bitmap_write (free_map, free_map_file))
     PANIC ("can't write free map");
 }
+
+
+// P4 tryout:
+// struct lock free_map_lock;
+
+// /* Initializes the free map. */
+// void free_map_init (void)
+// {
+//   free_map = bitmap_create (block_size (fs_device));
+//   if (free_map == NULL)
+//     PANIC ("bitmap creation failed--file system device is too large");
+//   bitmap_mark (free_map, FREE_MAP_SECTOR);
+//   bitmap_mark (free_map, ROOT_DIR_SECTOR);
+
+//   lock_init (&free_map_lock);
+// }
+
+// /* Allocates CNT consecutive sectors from the free map and stores
+//    the first into *SECTORP.
+//    Returns true if successful, false if not enough consecutive
+//    sectors were available or if the free_map file could not be
+//    written. */
+// bool free_map_allocate (size_t cnt, block_sector_t *sectorp)
+// {
+//   lock_acquire (&free_map_lock);
+//   block_sector_t sector = bitmap_scan_and_flip (free_map, 0, cnt, false);
+//   if (sector != BITMAP_ERROR && free_map_file != NULL &&
+//       !bitmap_write (free_map, free_map_file))
+//     {
+//       bitmap_set_multiple (free_map, sector, cnt, false);
+//       sector = BITMAP_ERROR;
+//     }
+//   lock_release (&free_map_lock);
+
+//   if (sector != BITMAP_ERROR)
+//     *sectorp = sector;
+  
+//   // Adjust free map file size after allocation
+//   // off_t new_size = bitmap_file_size(free_map);
+//   // if (new_size > inode_length(file_get_inode(free_map_file)))
+//   //   inode_extend(&file_get_inode(free_map_file)->data, new_size);
+
+//   return sector != BITMAP_ERROR;
+// }
+
+// // /* Makes CNT sectors starting at SECTOR available for use. */
+// void free_map_release (block_sector_t sector, size_t cnt)
+// {
+//   ASSERT (bitmap_all (free_map, sector, cnt));
+
+//   lock_acquire (&free_map_lock);
+//   bitmap_set_multiple (free_map, sector, cnt, false);
+//   bitmap_write (free_map, free_map_file);
+//   lock_release (&free_map_lock);
+// }
+
+// /* Opens the free map file and reads it from disk. */
+// void free_map_open (void)
+// {
+//   lock_acquire (&free_map_lock);
+//   free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
+//   lock_release (&free_map_lock);
+
+//   if (free_map_file == NULL)
+//     PANIC ("can't open free map");
+//   if (!bitmap_read (free_map, free_map_file))
+//     PANIC ("can't read free map");
+// }
+
+// /* Writes the free map to disk and closes the free map file. */
+// void free_map_close (void) {
+//   lock_acquire (&free_map_lock);
+//   file_close (free_map_file);
+//   lock_release (&free_map_lock);
+// }
+
+// /* Creates a new free map file on disk and writes the free map to
+//    it. */
+// void free_map_create (void)
+// {
+//   /* Create inode. */
+//   // if (!inode_create_2 (FREE_MAP_SECTOR, bitmap_file_size (free_map), false))
+//   if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map), false))
+//     PANIC ("free map creation failed");
+
+//   /* Write bitmap to file. */
+//   lock_acquire (&free_map_lock);
+//   free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
+//   lock_release (&free_map_lock);
+
+//   if (free_map_file == NULL)
+//     PANIC ("can't open free map");
+//   if (!bitmap_write (free_map, free_map_file))
+//     PANIC ("can't write free map");
+// }
diff -ruN aos_pintos/src/filesys/fsutil.c pintos-solution/src/filesys/fsutil.c
--- aos_pintos/src/filesys/fsutil.c	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/fsutil.c	2024-04-30 04:44:01.000000000 +0000
@@ -217,3 +217,218 @@
   file_close (src);
   free (buffer);
 }
+
+// P4 tryout:
+
+
+// #include "userprog/syscall.h"
+// #include "filesys/filesys.h"
+// #include "filesys/directory.h"
+
+// /* List files in the root directory. */
+// void fsutil_ls (char **argv UNUSED)
+// {
+//   struct dir *dir;
+//   char name[NAME_MAX + 1];
+
+//   printf ("Files in the root directory:\n");
+//   dir = dir_open_root ();
+//   if (dir == NULL)
+//     PANIC ("root dir open failed");
+//   while (dir_readdir (dir, name))
+//     printf ("%s\n", name);
+//   dir_close (dir);
+//   printf ("End of listing.\n");
+// }
+
+// /* Prints the contents of file ARGV[1] to the system console as
+//    hex and ASCII. */
+// void fsutil_cat (char **argv)
+// {
+//   const char *file_name = argv[1];
+
+//   struct file *file;
+//   char *buffer;
+
+//   printf ("Printing '%s' to the console...\n", file_name);
+//   file = filesys_open (file_name);
+//   if (file == NULL)
+//     PANIC ("%s: open failed", file_name);
+//   buffer = palloc_get_page (PAL_ASSERT);
+//   for (;;)
+//     {
+//       off_t pos = file_tell (file);
+//       off_t n = file_read (file, buffer, PGSIZE);
+//       if (n == 0)
+//         break;
+
+//       hex_dump (pos, buffer, n, true);
+//     }
+//   palloc_free_page (buffer);
+//   file_close (file);
+// }
+
+// /* Deletes file ARGV[1]. */
+// void fsutil_rm (char **argv)
+// {
+//   const char *file_name = argv[1];
+
+//   printf ("Deleting '%s'...\n", file_name);
+//   if (!filesys_remove (file_name))
+//     PANIC ("%s: delete failed\n", file_name);
+// }
+
+// /* Extracts a ustar-format tar archive from the scratch block
+//    device into the Pintos file system. */
+// void fsutil_extract (char **argv UNUSED)
+// {
+//   static block_sector_t sector = 0;
+
+//   struct block *src;
+//   void *header, *data;
+
+//   /* Allocate buffers. */
+//   header = malloc (BLOCK_SECTOR_SIZE);
+//   data = malloc (BLOCK_SECTOR_SIZE);
+//   if (header == NULL || data == NULL)
+//     PANIC ("couldn't allocate buffers");
+
+//   /* Open source block device. */
+//   src = block_get_role (BLOCK_SCRATCH);
+//   if (src == NULL)
+//     PANIC ("couldn't open scratch device");
+
+//   printf ("Extracting ustar archive from scratch device "
+//           "into file system...\n");
+
+//   for (;;)
+//     {
+//       const char *file_name;
+//       const char *error;
+//       enum ustar_type type;
+//       int size;
+
+//       /* Read and parse ustar header. */
+//       block_read (src, sector++, header);
+//       error = ustar_parse_header (header, &file_name, &type, &size);
+//       if (error != NULL)
+//         PANIC ("bad ustar header in sector %" PRDSNu " (%s)", sector - 1,
+//                error);
+
+//       if (type == USTAR_EOF)
+//         {
+//           /* End of archive. */
+//           break;
+//         }
+//       else if (type == USTAR_DIRECTORY)
+//         printf ("ignoring directory %s\n", file_name);
+//       else if (type == USTAR_REGULAR)
+//         {
+//           struct file *dst;
+
+//           printf ("Putting '%s' into the file system...\n", file_name);
+
+//           /* Create destination file. */
+//           // if (!filesys_create (file_name, size))
+//           if (!filesys_create (file_name, size, false))
+//             PANIC ("%s: create failed", file_name);
+//           dst = filesys_open (file_name);
+//           if (dst == NULL)
+//             PANIC ("%s: open failed", file_name);
+
+//           /* Do copy. */
+//           while (size > 0)
+//             {
+//               int chunk_size =
+//                   (size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size);
+//               block_read (src, sector++, data);
+//               if (file_write (dst, data, chunk_size) != chunk_size)
+//                 PANIC ("%s: write failed with %d bytes unwritten", file_name,
+//                        size);
+//               size -= chunk_size;
+//             }
+
+//           /* Finish up. */
+//           file_close (dst);
+//         }
+//     }
+
+//   /* Erase the ustar header from the start of the block device,
+//      so that the extraction operation is idempotent.  We erase
+//      two blocks because two blocks of zeros are the ustar
+//      end-of-archive marker. */
+//   printf ("Erasing ustar archive...\n");
+//   memset (header, 0, BLOCK_SECTOR_SIZE);
+//   block_write (src, 0, header);
+//   block_write (src, 1, header);
+
+//   free (data);
+//   free (header);
+// }
+
+// /* Copies file FILE_NAME from the file system to the scratch
+//    device, in ustar format.
+
+//    The first call to this function will write starting at the
+//    beginning of the scratch device.  Later calls advance across
+//    the device.  This position is independent of that used for
+//    fsutil_extract(), so `extract' should precede all
+//    `append's. */
+// void fsutil_append (char **argv)
+// {
+//   static block_sector_t sector = 0;
+
+//   const char *file_name = argv[1];
+//   void *buffer;
+//   struct file *src;
+//   struct block *dst;
+//   off_t size;
+
+//   printf ("Appending '%s' to ustar archive on scratch device...\n", file_name);
+
+//   /* Allocate buffer. */
+//   buffer = malloc (BLOCK_SECTOR_SIZE);
+//   if (buffer == NULL)
+//     PANIC ("couldn't allocate buffer");
+
+//   /* Open source file. */
+//   src = filesys_open (file_name);
+//   if (src == NULL)
+//     PANIC ("%s: open failed", file_name);
+//   size = file_length (src);
+
+//   /* Open target block device. */
+//   dst = block_get_role (BLOCK_SCRATCH);
+//   if (dst == NULL)
+//     PANIC ("couldn't open scratch device");
+
+//   /* Write ustar header to first sector. */
+//   if (!ustar_make_header (file_name, USTAR_REGULAR, size, buffer))
+//     PANIC ("%s: name too long for ustar format", file_name);
+//   block_write (dst, sector++, buffer);
+
+//   /* Do copy. */
+//   while (size > 0)
+//     {
+//       int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
+//       if (sector >= block_size (dst))
+//         PANIC ("%s: out of space on scratch device", file_name);
+//       if (file_read (src, buffer, chunk_size) != chunk_size)
+//         PANIC ("%s: read failed with %" PROTd " bytes unread", file_name, size);
+//       memset ((uint8_t *) buffer + chunk_size, 0,
+//               BLOCK_SECTOR_SIZE - chunk_size);
+//       block_write (dst, sector++, buffer);
+//       size -= chunk_size;
+//     }
+
+//   /* Write ustar end-of-archive marker, which is two consecutive
+//      sectors full of zeros.  Don't advance our position past
+//      them, though, in case we have more files to append. */
+//   memset (buffer, 0, BLOCK_SECTOR_SIZE);
+//   block_write (dst, sector, buffer);
+//   block_write (dst, sector + 1, buffer);
+
+//   /* Finish up. */
+//   file_close (src);
+//   free (buffer);
+// }
diff -ruN aos_pintos/src/filesys/inode.c pintos-solution/src/filesys/inode.c
--- aos_pintos/src/filesys/inode.c	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/inode.c	2024-04-30 04:40:00.000000000 +0000
@@ -10,6 +10,12 @@
 /* Identifies an inode. */
 #define INODE_MAGIC 0x494e4f44
 
+// P4 tryout:
+// #define DIRECT_BLOCKS 122
+// #define INDIRECT_BLOCKS 128
+// #define DOUBLY_INDIRECT_BLOCKS 128 * 128
+
+// P2 soltuion:
 /* On-disk inode.
    Must be exactly BLOCK_SECTOR_SIZE bytes long. */
 struct inode_disk
@@ -19,8 +25,18 @@
   unsigned magic;       /* Magic number. */
   bool is_symlink;      /* True if symbolic link, false otherwise. */
   uint32_t unused[124]; /* Not used. */
+
+// P4 tryout:
+//   block_sector_t direct_blocks[DIRECT_BLOCKS];  /* Direct block pointers. */
+//   block_sector_t indirect_block;      /* Indirect block pointer. */
+//   block_sector_t doubly_indirect_block; /* Doubly indirect block pointer. */
+//   bool is_dir;
 };
 
+// struct inode_indirect_block_sector {
+//   block_sector_t blocks[INDIRECT_BLOCKS];
+// };
+
 /* Returns the number of sectors to allocate for an inode SIZE
    bytes long. */
 static inline size_t bytes_to_sectors (off_t size)
@@ -337,3 +353,667 @@
   inode->data.is_symlink = is_symlink;
   block_write (fs_device, inode->sector, &inode->data);
 }
+
+
+
+// P4 tryout:
+
+// static block_sector_t
+// index_to_sector (const struct inode_disk *idisk, off_t index)
+// {
+//   off_t index_base = 0, index_limit = 0;   // base, limit for sector index
+//   block_sector_t ret;
+
+//   // (1) direct blocks
+//   index_limit += DIRECT_BLOCKS * 1;
+//   if (index < index_limit) {
+//     return idisk->direct_blocks[index];
+//   }
+//   index_base = index_limit;
+
+//   // (2) a single indirect block
+//   index_limit += 1 * INDIRECT_BLOCKS;
+//   if (index < index_limit) {
+//     struct inode_indirect_block_sector *indirect_idisk;
+//     indirect_idisk = calloc(1, sizeof(struct inode_indirect_block_sector));
+//     block_read (fs_device, idisk->indirect_block, indirect_idisk);
+
+//     ret = indirect_idisk->blocks[ index - index_base ];
+//     free(indirect_idisk);
+
+//     return ret;
+//   }
+//   index_base = index_limit;
+
+//   // (3) a single doubly indirect block
+//   index_limit += 1 * INDIRECT_BLOCKS * INDIRECT_BLOCKS;
+//   if (index < index_limit) {
+//     // first and second level block index, respecitvely
+//     off_t index_first =  (index - index_base) / INDIRECT_BLOCKS;
+//     off_t index_second = (index - index_base) % INDIRECT_BLOCKS;
+
+//     // fetch two indirect block sectors
+//     struct inode_indirect_block_sector *indirect_idisk;
+//     indirect_idisk = calloc(1, sizeof(struct inode_indirect_block_sector));
+
+//     block_read (fs_device, idisk->doubly_indirect_block, indirect_idisk);
+//     block_read (fs_device, indirect_idisk->blocks[index_first], indirect_idisk);
+//     ret = indirect_idisk->blocks[index_second];
+
+//     free(indirect_idisk);
+//     return ret;
+//   }
+
+//   // (4) what up?
+//   return -1;
+// }
+
+// block_sector_t byte_to_sector(const struct inode *inode, off_t pos)
+// {
+//   ASSERT(inode != NULL);
+//   if (0 <= pos && pos < inode->data.length) {
+//     // sector index
+//     off_t index = pos / BLOCK_SECTOR_SIZE;
+//     return index_to_sector (&inode->data, index);
+//   }
+//   else
+//     return -1;
+// }
+
+// /* List of open inodes, so that opening a single inode twice
+//    returns the same `struct inode'. */
+// static struct list open_inodes;
+// struct lock inode_lock;
+
+// /* Initializes the inode module. */
+// void inode_init (void) { list_init (&open_inodes); }
+
+// /* Initializes an inode with LENGTH bytes of data and
+//    writes the new inode to sector SECTOR on the file system
+//    device.
+//    Returns true if successful.
+//    Returns false if memory or disk allocation fails. */
+// bool inode_create (block_sector_t sector, off_t length, bool is_dir)
+// {
+//   struct inode_disk *disk_inode = NULL;
+//   bool success = false;
+
+//   ASSERT (length >= 0);
+
+//   /* If this assertion fails, the inode structure is not exactly
+//      one sector in size, and you should fix that. */
+//   ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);
+
+//   disk_inode = calloc (1, sizeof *disk_inode);
+//   if (disk_inode != NULL)
+//     {
+//       size_t sectors = bytes_to_sectors (length);
+//       disk_inode->length = length;
+//       disk_inode->magic = INODE_MAGIC;
+//       disk_inode->is_dir = is_dir;
+//       disk_inode->is_symlink = false;
+//       if (inode_allocate (disk_inode))
+//         {
+//           block_write (fs_device, sector, disk_inode);
+//           success = true;
+//         }
+//       free (disk_inode);
+//     }
+//   return success;
+// }
+
+// /* Reads an inode from SECTOR
+//    and returns a `struct inode' that contains it.
+//    Returns a null pointer if memory allocation fails. */
+// struct inode *inode_open (block_sector_t sector)
+// {
+//   struct list_elem *e;
+//   struct inode *inode;
+
+//   /* Check whether this inode is already open. */
+//   for (e = list_begin (&open_inodes); e != list_end (&open_inodes);
+//        e = list_next (e))
+//     {
+//       inode = list_entry (e, struct inode, elem);
+//       if (inode->sector == sector)
+//         {
+//           inode_reopen (inode);
+//           return inode;
+//         }
+//     }
+
+//   /* Allocate memory. */
+//   inode = malloc (sizeof *inode);
+//   if (inode == NULL)
+//     return NULL;
+
+//   /* Initialize. */
+//   list_push_front (&open_inodes, &inode->elem);
+//   inode->sector = sector;
+//   inode->open_cnt = 1;
+//   inode->deny_write_cnt = 0;
+//   inode->removed = false;
+//   block_read (fs_device, inode->sector, &inode->data);
+//   return inode;
+// }
+
+// /* Reopens and returns INODE. */
+// struct inode *inode_reopen (struct inode *inode)
+// {
+//   if (inode != NULL)
+//     inode->open_cnt++;
+//   return inode;
+// }
+
+// /* Returns INODE's inode number. */
+// block_sector_t inode_get_inumber (const struct inode *inode)
+// {
+//   return inode->sector;
+// }
+
+// /* Closes INODE and writes it to disk. (Does it?  Check code.)
+//    If this was the last reference to INODE, frees its memory.
+//    If INODE was also a removed inode, frees its blocks. */
+// void inode_close (struct inode *inode)
+// {
+//   /* Ignore null pointer. */
+//   if (inode == NULL)
+//     return;
+
+//   /* Release resources if this was the last opener. */
+//   if (--inode->open_cnt == 0)
+//     {
+//       /* Remove from inode list and release lock. */
+//       list_remove (&inode->elem);
+
+//       /* Deallocate blocks if removed. */
+//       if (inode->removed)
+//         {
+//           free_map_release (inode->sector, 1);
+//           inode_deallocate (inode);
+//         }
+
+//       free (inode);
+//     }
+// }
+
+
+// /* Marks INODE to be deleted when it is closed by the last caller who
+//    has it open. */
+// void inode_remove (struct inode *inode)
+// {
+//   ASSERT (inode != NULL);
+//   inode->removed = true;
+// }
+
+// /* Reads SIZE bytes from INODE into BUFFER, starting at position OFFSET.
+//    Returns the number of bytes actually read, which may be less
+//    than SIZE if an error occurs or end of file is reached. */
+// off_t inode_read_at (struct inode *inode, void *buffer_, off_t size,
+//                      off_t offset)
+// {
+//   uint8_t *buffer = buffer_;
+//   off_t bytes_read = 0;
+//   uint8_t *bounce = NULL;
+
+//   while (size > 0)
+//     {
+//       /* Disk sector to read, starting byte offset within sector. */
+//       block_sector_t sector_idx = byte_to_sector (inode, offset);
+//       int sector_ofs = offset % BLOCK_SECTOR_SIZE;
+
+//       /* Bytes left in inode, bytes left in sector, lesser of the two. */
+//       off_t inode_left = inode_length (inode) - offset;
+//       int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
+//       int min_left = inode_left < sector_left ? inode_left : sector_left;
+
+//       /* Number of bytes to actually copy out of this sector. */
+//       int chunk_size = size < min_left ? size : min_left;
+//       if (chunk_size <= 0)
+//         break;
+
+//       if (sector_idx == (block_sector_t)-1) {
+//         if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
+//           {
+//             /* Read full sector directly into caller's buffer. */
+//             block_read (fs_device, sector_idx, buffer + bytes_read);
+//           }
+//         else
+//           {
+//             /* Read sector into bounce buffer, then partially copy
+//               into caller's buffer. */
+//             if (bounce == NULL)
+//               {
+//                 bounce = malloc (BLOCK_SECTOR_SIZE);
+//                 if (bounce == NULL)
+//                   break;
+//               }
+//             block_read (fs_device, sector_idx, bounce);
+//             memcpy (buffer + bytes_read, bounce + sector_ofs, chunk_size);
+//           }
+//       } else {
+//         // Reading from unallocated block, fill buffer with zeros
+//         memset(buffer + bytes_read, 0, chunk_size);
+//       }
+
+//       /* Advance. */
+//       size -= chunk_size;
+//       offset += chunk_size;
+//       bytes_read += chunk_size;
+//     }
+//   free (bounce);
+
+//   return bytes_read;
+// }
+
+// /* Writes SIZE bytes from BUFFER into INODE, starting at OFFSET.
+//    Returns the number of bytes actually written, which may be
+//    less than SIZE if end of file is reached or an error occurs.
+//    (Normally a write at end of file would extend the inode, but
+//    growth is not yet implemented.) */
+// off_t inode_write_at (struct inode *inode, const void *buffer_, off_t size,
+//                       off_t offset)
+// {
+//   const uint8_t *buffer = buffer_;
+//   off_t bytes_written = 0;
+//   uint8_t *bounce = NULL;
+
+//   if (inode->deny_write_cnt)
+//     return 0;
+
+//   // beyond the EOF: extend the file
+//   if( byte_to_sector(inode, offset + size - 1) == -1u ) {
+//     // extend and reserve up to [offset + size] bytes
+//     bool success;
+//     success = inode_reserve (& inode->data, offset + size);
+//     if (!success) return 0;  // fail?
+
+//     // write back the (extended) file size
+//     inode->data.length = offset + size;
+//     block_write (fs_device, inode->sector, & inode->data);
+//   }
+
+//   while (size > 0)
+//     {
+//       /* Sector to write, starting byte offset within sector. */
+//       block_sector_t sector_idx = byte_to_sector (inode, offset);
+//       int sector_ofs = offset % BLOCK_SECTOR_SIZE;
+
+//       /* Bytes left in inode, bytes left in sector, lesser of the two. */
+//       off_t inode_left = inode_length (inode) - offset;
+//       int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
+//       int min_left = inode_left < sector_left ? inode_left : sector_left;
+
+//       /* Number of bytes to actually write into this sector. */
+//       int chunk_size = size < min_left ? size : min_left;
+//       if (chunk_size <= 0)
+//         break;
+
+//       if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
+//         {
+//           /* Write full sector directly to disk. */
+//           block_write (fs_device, sector_idx, buffer + bytes_written);
+//         }
+//       else
+//         {
+//           /* We need a bounce buffer. */
+//           if (bounce == NULL)
+//             {
+//               bounce = malloc (BLOCK_SECTOR_SIZE);
+//               if (bounce == NULL)
+//                 break;
+//             }
+
+//           /* If the sector contains data before or after the chunk
+//              we're writing, then we need to read in the sector
+//              first.  Otherwise we start with a sector of all zeros. */
+//           if (sector_ofs > 0 || chunk_size < sector_left)
+//             block_read (fs_device, sector_idx, bounce);
+//           else
+//             memset (bounce, 0, BLOCK_SECTOR_SIZE);
+//           memcpy (bounce + sector_ofs, buffer + bytes_written, chunk_size);
+//           block_write (fs_device, sector_idx, bounce);
+//         }
+
+//       /* Advance. */
+//       size -= chunk_size;
+//       offset += chunk_size;
+//       bytes_written += chunk_size;
+//     }
+//   free (bounce);
+
+//   return bytes_written;
+// }
+
+// /* Disables writes to INODE.
+//    May be called at most once per inode opener. */
+// void inode_deny_write (struct inode *inode)
+// {
+//   inode->deny_write_cnt++;
+//   ASSERT (inode->deny_write_cnt <= inode->open_cnt);
+// }
+
+// /* Re-enables writes to INODE.
+//    Must be called once by each inode opener who has called
+//    inode_deny_write() on the inode, before closing the inode. */
+// void inode_allow_write (struct inode *inode)
+// {
+//   ASSERT (inode->deny_write_cnt > 0);
+//   ASSERT (inode->deny_write_cnt <= inode->open_cnt);
+//   inode->deny_write_cnt--;
+// }
+
+// /* Returns the length, in bytes, of INODE's data. */
+// off_t inode_length (const struct inode *inode) { return inode->data.length; }
+
+// bool inode_get_symlink (struct inode *inode) { 
+//   ASSERT (inode != NULL);
+//   return inode->data.is_symlink; 
+// }
+
+// void inode_set_symlink (struct inode *inode, bool is_symlink)
+// {
+//   inode->data.is_symlink = is_symlink;
+//   block_write (fs_device, inode->sector, &inode->data);
+// }
+
+// bool inode_expand (struct inode_disk *disk_inode, off_t new_length)
+// {
+//   off_t old_length = disk_inode->length;
+//   off_t sectors_needed = bytes_to_sectors(new_length) - bytes_to_sectors(old_length);
+//   if (sectors_needed <= 0)
+//     return true; // No expansion needed
+
+//   size_t i;
+
+//   // Direct blocks
+//   for (i = 0; i < DIRECT_BLOCKS && sectors_needed > 0; ++i)
+//   {
+//     if (disk_inode->direct_blocks[i] == 0)
+//     {
+//       if (!free_map_allocate(1, &disk_inode->direct_blocks[i]))
+//         return false;
+//       --sectors_needed;
+//     }
+//   }
+
+//   // Indirect block
+//   if (sectors_needed > 0 && disk_inode->indirect_block == 0)
+//   {
+//     if (!free_map_allocate(1, &disk_inode->indirect_block))
+//       return false;
+//     --sectors_needed;
+//   }
+
+//   // Doubly indirect block
+//   if (sectors_needed > 0 && disk_inode->doubly_indirect_block == 0)
+//   {
+//     if (!free_map_allocate(1, &disk_inode->doubly_indirect_block))
+//       return false;
+//     --sectors_needed;
+//   }
+
+//   return sectors_needed <= 0;
+// }
+
+// off_t inode_extend (struct inode_disk *disk_inode, off_t new_length)
+// {
+//   if (new_length > disk_inode->length)
+//   {
+//     if (!inode_expand(disk_inode, new_length))
+//       return disk_inode->length;
+//     disk_inode->length = new_length;
+//   }
+//   return disk_inode->length;
+// }
+
+// bool inode_is_dir(const struct inode *inode)
+// {
+//     return inode != NULL && inode->data.is_dir;
+// }
+
+// /* Open an inode given its path. */
+// struct inode *inode_open_path(const char *path)
+// {
+//     struct inode *inode = NULL;
+//     struct dir *dir = NULL;
+//     char *path_copy = NULL;
+//     char *token, *save_ptr;
+
+//     /* Check if path is not null */
+//     if (path == NULL)
+//         return NULL;
+
+//     /* Make a copy of path for tokenizing */
+//     path_copy = malloc(strlen(path) + 1);
+//     if (path_copy == NULL)
+//         return NULL;
+//     strlcpy(path_copy, path, strlen(path) + 1);
+
+//     /* Tokenize the path to traverse directories */
+//     token = strtok_r(path_copy, "/", &save_ptr);
+//     if (token == NULL) {
+//         free(path_copy);
+//         return NULL; // Empty path
+//     }
+
+//     /* Open the root directory initially */
+//     dir = dir_open_root();
+//     if (dir == NULL) {
+//         free(path_copy);
+//         return NULL; // Failed to open root directory
+//     }
+
+//     /* Traverse through each token in the path */
+//     while (token != NULL && dir != NULL) {
+//         /* Lookup the entry corresponding to the token */
+//         if (!dir_lookup(dir, token, &inode)) {
+//             dir_close(dir);
+//             free(path_copy);
+//             return NULL; // Entry not found
+//         }
+
+//         /* Check if the inode is a directory */
+//         if (inode_is_dir(inode)) {
+//             /* Close the current directory and open the subdirectory */
+//             dir_close(dir);
+//             dir = dir_open(inode);
+//         } else {
+//             /* Not a directory, close the directory */
+//             dir_close(dir);
+//             dir = NULL;
+//         }
+
+//         /* Move to the next token */
+//         token = strtok_r(NULL, "/", &save_ptr);
+//     }
+
+//     free(path_copy);
+//     return inode;
+// }
+
+// /* Returns the physical length of the inode's data. */
+// off_t inode_length_physical(const struct inode *inode) {
+//     lock_acquire(&inode_lock);
+//     off_t length = inode->data.length;
+//     lock_release(&inode_lock);
+//     return length;
+// }
+
+// /* Returns the number of blocks allocated to the inode. */
+// blkcnt_t inode_get_blocks(const struct inode *inode) {
+//     lock_acquire(&inode_lock);
+//     off_t length = inode->data.length;
+//     blkcnt_t blocks = (length + BLOCK_SECTOR_SIZE - 1) / BLOCK_SECTOR_SIZE;
+//     lock_release(&inode_lock);
+//     return blocks;
+// }
+
+// /* Returns whether the file is removed or not. */
+// bool
+// inode_is_removed (const struct inode *inode)
+// {
+//   return inode->removed;
+// }
+
+// static inline size_t
+// min (size_t a, size_t b)
+// {
+//   return a < b ? a : b;
+// }
+
+// static
+// bool inode_allocate (struct inode_disk *disk_inode)
+// {
+//   return inode_reserve (disk_inode, disk_inode->length);
+// }
+
+// static bool
+// inode_reserve_indirect (block_sector_t* p_entry, size_t num_sectors, int level)
+// {
+//   static char zeros[BLOCK_SECTOR_SIZE];
+
+//   // only supports 2-level indirect block scheme as of now
+//   ASSERT (level <= 2);
+
+//   if (level == 0) {
+//     // base case : allocate a single sector if necessary and put it into the block
+//     if (*p_entry == 0) {
+//       if(! free_map_allocate (1, p_entry))
+//         return false;
+//       block_write (fs_device, *p_entry, zeros);
+//     }
+//     return true;
+//   }
+
+//   struct inode_indirect_block_sector indirect_block;
+//   if(*p_entry == 0) {
+//     // not yet allocated: allocate it, and fill with zero
+//     free_map_allocate (1, p_entry);
+//     block_write (fs_device,*p_entry, zeros);
+//   }
+//   block_read (fs_device, *p_entry, &indirect_block);
+
+//   size_t unit = (level == 1 ? 1 : INDIRECT_BLOCKS);
+//   size_t i, l = DIV_ROUND_UP (num_sectors, unit);
+
+//   for (i = 0; i < l; ++ i) {
+//     size_t subsize = min(num_sectors, unit);
+//     // inode_reserve_indirect (& indirect_block.blocks[i], subsize, level - 1);
+//     if(! inode_reserve_indirect (& indirect_block.blocks[i], subsize, level - 1))
+//       return false;
+//     num_sectors -= subsize;
+//   }
+
+//   ASSERT (num_sectors == 0);
+//   block_write (fs_device, *p_entry, &indirect_block);
+//   return true;
+// }
+
+// static bool
+// inode_reserve (struct inode_disk *disk_inode, off_t length)
+// {
+//   static char zeros[BLOCK_SECTOR_SIZE];
+
+//   if (length < 0) return false;
+
+//   // (remaining) number of sectors, occupied by this file.
+//   size_t num_sectors = bytes_to_sectors(length);
+//   size_t i, l;
+
+//   // (1) direct blocks
+//   l = min(num_sectors, DIRECT_BLOCKS * 1);
+//   for (i = 0; i < l; ++ i) {
+//     if (disk_inode->direct_blocks[i] == 0) { // unoccupied
+//       // free_map_allocate (1, &disk_inode->direct_blocks[i]);
+//       if(! free_map_allocate (1, &disk_inode->direct_blocks[i]))
+//         return false;
+//       block_write (fs_device, disk_inode->direct_blocks[i], zeros);
+//     }
+//   }
+//   num_sectors -= l;
+//   if(num_sectors == 0) return true;
+
+//   // (2) a single indirect block
+//   l = min(num_sectors, 1 * INDIRECT_BLOCKS);
+//   // inode_reserve_indirect (& disk_inode->indirect_block, l, 1);
+//   if(! inode_reserve_indirect (& disk_inode->indirect_block, l, 1))
+//     return false;
+//   num_sectors -= l;
+//   if(num_sectors == 0) return true;
+
+//   // (3) a single doubly indirect block
+//   l = min(num_sectors, 1 * INDIRECT_BLOCKS * INDIRECT_BLOCKS);
+//   // inode_reserve_indirect (& disk_inode->doubly_indirect_block, l, 2);
+//   if(! inode_reserve_indirect (& disk_inode->doubly_indirect_block, l, 2))
+//     return false;
+//   num_sectors -= l;
+//   if(num_sectors == 0) return true;
+
+//   ASSERT (num_sectors == 0);
+//   return false;
+// }
+
+// static void
+// inode_deallocate_indirect (block_sector_t entry, size_t num_sectors, int level)
+// {
+//   // only supports 2-level indirect block scheme as of now
+//   ASSERT (level <= 2);
+
+//   if (level == 0) {
+//     free_map_release (entry, 1);
+//     return;
+//   }
+
+//   struct inode_indirect_block_sector indirect_block;
+//   block_read (fs_device, entry, &indirect_block);
+
+//   size_t unit = (level == 1 ? 1 : INDIRECT_BLOCKS);
+//   size_t i, l = DIV_ROUND_UP (num_sectors, unit);
+
+//   for (i = 0; i < l; ++ i) {
+//     size_t subsize = min(num_sectors, unit);
+//     inode_deallocate_indirect (indirect_block.blocks[i], subsize, level - 1);
+//     num_sectors -= subsize;
+//   }
+
+//   ASSERT (num_sectors == 0);
+//   free_map_release (entry, 1);
+// }
+
+// static
+// bool inode_deallocate (struct inode *inode)
+// {
+//   off_t file_length = inode->data.length; // bytes
+//   if(file_length < 0) return false;
+
+//   // (remaining) number of sectors, occupied by this file.
+//   size_t num_sectors = bytes_to_sectors(file_length);
+//   size_t i, l;
+
+//   // (1) direct blocks
+//   l = min(num_sectors, DIRECT_BLOCKS * 1);
+//   for (i = 0; i < l; ++ i) {
+//     free_map_release (inode->data.direct_blocks[i], 1);
+//   }
+//   num_sectors -= l;
+
+//   // (2) a single indirect block
+//   l = min(num_sectors, 1 * INDIRECT_BLOCKS);
+//   if(l > 0) {
+//     inode_deallocate_indirect (inode->data.indirect_block, l, 1);
+//     num_sectors -= l;
+//   }
+
+//   // (3) a single doubly indirect block
+//   l = min(num_sectors, 1 * INDIRECT_BLOCKS * INDIRECT_BLOCKS);
+//   if(l > 0) {
+//     inode_deallocate_indirect (inode->data.doubly_indirect_block, l, 2);
+//     num_sectors -= l;
+//   }
+
+//   ASSERT (num_sectors == 0);
+//   return true;
+// }
+
+
diff -ruN aos_pintos/src/filesys/inode.h pintos-solution/src/filesys/inode.h
--- aos_pintos/src/filesys/inode.h	2024-02-29 23:23:29.000000000 +0000
+++ pintos-solution/src/filesys/inode.h	2024-04-30 04:38:41.000000000 +0000
@@ -22,4 +22,14 @@
 bool inode_get_symlink (struct inode *inode);
 void inode_set_symlink (struct inode *inode, bool is_symlink);
 
+// P4 tryout:
+// bool inode_expand (struct inode_disk *disk_inode, off_t new_length);
+// off_t inode_extend (struct inode_disk *disk_inode, off_t new_length);
+// block_sector_t byte_to_sector(const struct inode *inode, off_t pos);
+// bool inode_is_dir(const struct inode *inode);
+// struct inode *inode_open_path(const char *path);
+// off_t inode_length_physical(const struct inode *inode);
+// blkcnt_t inode_get_blocks(const struct inode *inode);
+// bool inode_is_removed (const struct inode *);
+
 #endif /* filesys/inode.h */
Binary files aos_pintos/src/tests/.DS_Store and pintos-solution/src/tests/.DS_Store differ
Binary files aos_pintos/src/tests/filesys/.DS_Store and pintos-solution/src/tests/filesys/.DS_Store differ
diff -ruN aos_pintos/src/tests/userprog/Rubric.functionality pintos-solution/src/tests/userprog/Rubric.functionality
--- aos_pintos/src/tests/userprog/Rubric.functionality	2024-02-29 23:23:14.000000000 +0000
+++ pintos-solution/src/tests/userprog/Rubric.functionality	2024-03-31 05:11:46.000000000 +0000
@@ -44,10 +44,10 @@
 3	halt
 
 - Test "symlink" system call.
-5	symlink-bad-target
-5	symlink-check
-5	symlink-remove
-10	symlink-read
+5	sl-bad-target
+5	sl-check
+5	sl-remove
+10	sl-read
 
 - Test recursive execution of user programs.
 15	multi-recurse
diff -ruN aos_pintos/src/tests/userprog/sl-read.c pintos-solution/src/tests/userprog/sl-read.c
--- aos_pintos/src/tests/userprog/sl-read.c	2024-02-29 23:23:07.000000000 +0000
+++ pintos-solution/src/tests/userprog/sl-read.c	2024-03-31 05:11:44.000000000 +0000
@@ -27,12 +27,11 @@
   CHECK ((link_fd = open ("test-link.txt")) > 1, "open \"test-link.txt\"");
 
   char content[] = "This is a test";
-  CHECK (write (target_fd, content, sizeof content - 1) == sizeof content - 1,
+  CHECK (write (target_fd, content, sizeof content) == sizeof content,
          "write content to \"test.txt\"");
   char buf[sizeof content];
-  CHECK (read (link_fd, buf, sizeof content - 1) == sizeof content - 1,
+  CHECK (read (link_fd, buf, sizeof content) == sizeof content,
          "read \"test-link.txt\"");
 
-  buf[sizeof content] = '\0';
   msg ("test-link.txt reads: '%s'", buf);
-}
+}
\ No newline at end of file
diff -ruN aos_pintos/src/threads/palloc.c pintos-solution/src/threads/palloc.c
--- aos_pintos/src/threads/palloc.c	2024-02-29 23:23:01.000000000 +0000
+++ pintos-solution/src/threads/palloc.c	2024-03-31 05:11:48.000000000 +0000
@@ -147,7 +147,8 @@
 {
   /* We'll put the pool's used_map at its base.
      Calculate the space needed for the bitmap
-     and subtract it from the pool's size. */
+     and subtract it from the pool's size. 
+     [placeholder] - it is turtles all the way down */
   size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
   if (bm_pages > page_cnt)
     PANIC ("Not enough memory in %s for bitmap.", name);
diff -ruN aos_pintos/src/threads/thread.c pintos-solution/src/threads/thread.c
--- aos_pintos/src/threads/thread.c	2024-02-29 23:23:01.000000000 +0000
+++ pintos-solution/src/threads/thread.c	2024-03-31 05:11:48.000000000 +0000
@@ -11,8 +11,13 @@
 #include "threads/switch.h"
 #include "threads/synch.h"
 #include "threads/vaddr.h"
+#include "lib/kernel/stdio.h"
+#include "threads/malloc.h"
+#include "userprog/process.h"
 #ifdef USERPROG
 #include "userprog/process.h"
+#include "filesys/filesys.h"
+#include "filesys/file.h"
 #endif
 
 /* Random value for struct thread's `magic' member.
@@ -193,6 +198,30 @@
   sf->eip = switch_entry;
   sf->ebp = 0;
 
+  t->parent = thread_current (); // Creating thread is parent of new thread
+
+  // Add new thread to children struct of parent
+  struct child *child = malloc (sizeof (struct child));
+  child->child_thread = t;
+  child->exit_status = -1;
+  child->pid = tid;
+  sema_init(&child->exited, 0);
+  list_push_front (&thread_current()->children, &child->elem);
+
+  t->fd_table = (struct file **) palloc_get_page(PAL_USER | PAL_ZERO);
+  if (t->fd_table == NULL){
+    free(child);
+    palloc_free_page(t);
+    return TID_ERROR;
+  }
+  
+  // Deny writes to currently executing file
+  if (strcmp("idle", name)){
+    t->fd_table[0] = filesys_open(name);
+    if (t->fd_table[0] != NULL)
+      file_deny_write(t->fd_table[0]);
+  }
+
   /* Add to run queue. */
   thread_unblock (t);
 
@@ -432,6 +461,9 @@
   old_level = intr_disable ();
   list_push_back (&all_list, &t->allelem);
   intr_set_level (old_level);
+
+  sema_init (&t->child_created, 0);
+  list_init (&t->children);
 }
 
 /* Allocates a SIZE-byte frame at the top of thread T's stack and
diff -ruN aos_pintos/src/threads/thread.h pintos-solution/src/threads/thread.h
--- aos_pintos/src/threads/thread.h	2024-02-29 23:23:01.000000000 +0000
+++ pintos-solution/src/threads/thread.h	2024-04-30 04:52:23.000000000 +0000
@@ -4,6 +4,7 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -95,11 +96,22 @@
   /* Shared between thread.c and synch.c. */
   struct list_elem elem; /* List element. */
 
+  struct thread* parent; // Pointer to parent thread
+  struct list children; // List of children threads & metadata
+
+  struct semaphore child_created; // Synchronize exec method
+  bool success; // Was exec successful 
+
+  struct file** fd_table; // Map fd (index) to files
+
 #ifdef USERPROG
   /* Owned by userprog/process.c. */
   uint32_t *pagedir; /* Page directory. */
 #endif
 
+   // P4 tryout:
+   // struct dir *cwd;
+
   /* Owned by thread.c. */
   unsigned magic; /* Detects stack overflow. */
 };
diff -ruN aos_pintos/src/userprog/exception.c pintos-solution/src/userprog/exception.c
--- aos_pintos/src/userprog/exception.c	2024-02-29 23:23:01.000000000 +0000
+++ pintos-solution/src/userprog/exception.c	2024-03-31 05:11:48.000000000 +0000
@@ -1,4 +1,5 @@
 #include "userprog/exception.h"
+#include "userprog/syscall.h"
 #include <inttypes.h>
 #include <stdio.h>
 #include "userprog/gdt.h"
@@ -140,15 +141,6 @@
   not_present = (f->error_code & PF_P) == 0;
   write = (f->error_code & PF_W) != 0;
   user = (f->error_code & PF_U) != 0;
-
-  /* To implement virtual memory, delete the rest of the function
-     body, and replace it with code that brings in the page to
-     which fault_addr refers. */
-  printf ("Page fault at %p: %s error %s page in %s context.\n", fault_addr,
-          not_present ? "not present" : "rights violation",
-          write ? "writing" : "reading", user ? "user" : "kernel");
-
-  printf ("There is no crying in Pintos!\n");
-
-  kill (f);
+  
+  exit(-1);
 }
diff -ruN aos_pintos/src/userprog/process.c pintos-solution/src/userprog/process.c
--- aos_pintos/src/userprog/process.c	2024-02-29 23:23:00.000000000 +0000
+++ pintos-solution/src/userprog/process.c	2024-03-31 05:11:48.000000000 +0000
@@ -8,6 +8,7 @@
 #include "userprog/gdt.h"
 #include "userprog/pagedir.h"
 #include "userprog/tss.h"
+#include "userprog/syscall.h"
 #include "filesys/directory.h"
 #include "filesys/file.h"
 #include "filesys/filesys.h"
@@ -15,11 +16,14 @@
 #include "threads/init.h"
 #include "threads/interrupt.h"
 #include "threads/palloc.h"
+#include "threads/malloc.h"
+#include "lib/string.h"
 #include "threads/thread.h"
 #include "threads/vaddr.h"
 
+#define ALIGN(ADDR) ((void *) ((uintptr_t) ADDR - (uintptr_t) ADDR % 4))
+
 static thread_func start_process NO_RETURN;
-static bool load (const char *cmdline, void (**eip) (void), void **esp);
 
 /* Starts a new thread running a user program loaded from
    FILENAME.  The new thread may be scheduled (and may even exit)
@@ -37,8 +41,16 @@
     return TID_ERROR;
   strlcpy (fn_copy, file_name, PGSIZE);
 
+  // Get executable name for thread create
+  char *save_ptr;
+  const char delimiter[7] = " \t\r\n\f\v";
+  int len = strlen (file_name);
+  char args_copy[len + 1];
+  strlcpy (args_copy, file_name, len + 1);
+  char *exec_name = strtok_r ((char *) args_copy, delimiter, &save_ptr);
+
   /* Create a new thread to execute FILE_NAME. */
-  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);
+  tid = thread_create (exec_name, PRI_DEFAULT, start_process, fn_copy);
   if (tid == TID_ERROR)
     palloc_free_page (fn_copy);
   return tid;
@@ -46,9 +58,8 @@
 
 /* A thread function that loads a user process and starts it
    running. */
-static void start_process (void *file_name_)
+static void start_process (void *filename)
 {
-  char *file_name = file_name_;
   struct intr_frame if_;
   bool success;
 
@@ -57,12 +68,20 @@
   if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
   if_.cs = SEL_UCSEG;
   if_.eflags = FLAG_IF | FLAG_MBS;
-  success = load (file_name, &if_.eip, &if_.esp);
+  success = load (filename, &if_.eip, &if_.esp);
+
+  if (!is_kernel_vaddr (filename))
+    palloc_free_page (filename);
+
+  thread_current ()->parent->success = success;
+  sema_up (&thread_current ()->parent->child_created);
 
   /* If load failed, quit. */
-  palloc_free_page (file_name);
+  palloc_free_page (filename);
   if (!success)
-    thread_exit ();
+    {
+      exit (-1);
+    }
 
   /* Start the user process by simulating a return from an
      interrupt, implemented by intr_exit (in
@@ -70,7 +89,7 @@
      arguments on the stack in the form of a `struct intr_frame',
      we just point the stack pointer (%esp) to our stack frame
      and jump to it. */
-  asm volatile("movl %0, %%esp; jmp intr_exit" : : "g"(&if_) : "memory");
+  asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g"(&if_) : "memory");
   NOT_REACHED ();
 }
 
@@ -83,7 +102,33 @@
 
    This function will be implemented in problem 2-2.  For now, it
    does nothing. */
-int process_wait (tid_t child_tid UNUSED) { return -1; }
+int process_wait (tid_t child_tid UNUSED)
+{
+  struct thread *parent = thread_current ();
+  struct list *children = &parent->children;
+
+  if (list_empty (children))
+    {
+      return -1;
+    }
+
+  // Find child if in children list and wait on its exit returning status
+  struct list_elem *curr;
+  for (curr = list_front (children); curr != list_end (children);
+       curr = list_next (curr))
+    {
+      struct child *curr_item = list_entry (curr, struct child, elem);
+      if (curr_item->pid == child_tid)
+        {
+          sema_down (&curr_item->exited);
+          list_remove (curr);
+          int status = curr_item->exit_status;
+          free (curr_item);
+          return status;
+        }
+    }
+  return -1;
+}
 
 /* Free the current process's resources. */
 void process_exit (void)
@@ -124,54 +169,6 @@
   tss_update ();
 }
 
-/* We load ELF binaries.  The following definitions are taken
-   from the ELF specification, [ELF1], more-or-less verbatim.  */
-
-/* ELF types.  See [ELF1] 1-2. */
-typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;
-typedef uint16_t Elf32_Half;
-
-/* For use with ELF types in printf(). */
-#define PE32Wx PRIx32 /* Print Elf32_Word in hexadecimal. */
-#define PE32Ax PRIx32 /* Print Elf32_Addr in hexadecimal. */
-#define PE32Ox PRIx32 /* Print Elf32_Off in hexadecimal. */
-#define PE32Hx PRIx16 /* Print Elf32_Half in hexadecimal. */
-
-/* Executable header.  See [ELF1] 1-4 to 1-8.
-   This appears at the very beginning of an ELF binary. */
-struct Elf32_Ehdr
-{
-  unsigned char e_ident[16];
-  Elf32_Half e_type;
-  Elf32_Half e_machine;
-  Elf32_Word e_version;
-  Elf32_Addr e_entry;
-  Elf32_Off e_phoff;
-  Elf32_Off e_shoff;
-  Elf32_Word e_flags;
-  Elf32_Half e_ehsize;
-  Elf32_Half e_phentsize;
-  Elf32_Half e_phnum;
-  Elf32_Half e_shentsize;
-  Elf32_Half e_shnum;
-  Elf32_Half e_shstrndx;
-};
-
-/* Program header.  See [ELF1] 2-2 to 2-4.
-   There are e_phnum of these, starting at file offset e_phoff
-   (see [ELF1] 1-6). */
-struct Elf32_Phdr
-{
-  Elf32_Word p_type;
-  Elf32_Off p_offset;
-  Elf32_Addr p_vaddr;
-  Elf32_Addr p_paddr;
-  Elf32_Word p_filesz;
-  Elf32_Word p_memsz;
-  Elf32_Word p_flags;
-  Elf32_Word p_align;
-};
-
 /* Values for p_type.  See [ELF1] 2-3. */
 #define PT_NULL 0           /* Ignore. */
 #define PT_LOAD 1           /* Loadable segment. */
@@ -187,7 +184,7 @@
 #define PF_W 2 /* Writable. */
 #define PF_R 4 /* Readable. */
 
-static bool setup_stack (void **esp);
+static bool setup_stack (void **esp, const char *filename);
 static bool validate_segment (const struct Elf32_Phdr *, struct file *);
 static bool load_segment (struct file *file, off_t ofs, uint8_t *upage,
                           uint32_t read_bytes, uint32_t zero_bytes,
@@ -197,14 +194,21 @@
    Stores the executable's entry point into *EIP
    and its initial stack pointer into *ESP.
    Returns true if successful, false otherwise. */
-bool load (const char *file_name, void (**eip) (void), void **esp)
+bool load (const char *args, void (**eip) (void), void **esp)
 {
   struct thread *t = thread_current ();
   struct Elf32_Ehdr ehdr;
   struct file *file = NULL;
   off_t file_ofs;
   bool success = false;
-  int i;
+  int argc;
+
+  char *save_ptr;
+  const char delimiter[7] = " \t\r\n\f\v";
+  int len = strlen (args);
+  char args_copy[len + 1];
+  strlcpy (args_copy, args, len + 1);
+  char *filename = strtok_r ((char *) args_copy, delimiter, &save_ptr);
 
   /* Allocate and activate page directory. */
   t->pagedir = pagedir_create ();
@@ -213,10 +217,10 @@
   process_activate ();
 
   /* Open executable file. */
-  file = filesys_open (file_name);
+  file = filesys_open (filename);
   if (file == NULL)
     {
-      printf ("load: %s: open failed\n", file_name);
+      printf ("load: %s: open failed\n", filename);
       goto done;
     }
 
@@ -226,13 +230,13 @@
       ehdr.e_machine != 3 || ehdr.e_version != 1 ||
       ehdr.e_phentsize != sizeof (struct Elf32_Phdr) || ehdr.e_phnum > 1024)
     {
-      printf ("load: %s: error loading executable\n", file_name);
+      printf ("load: %s: error loading executable\n", filename);
       goto done;
     }
 
   /* Read program headers. */
   file_ofs = ehdr.e_phoff;
-  for (i = 0; i < ehdr.e_phnum; i++)
+  for (argc = 0; argc < ehdr.e_phnum; argc++)
     {
       struct Elf32_Phdr phdr;
 
@@ -243,6 +247,9 @@
       if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
         goto done;
       file_ofs += sizeof phdr;
+      
+      // [placeholder] - it is turtles all the way down
+      
       switch (phdr.p_type)
         {
           case PT_NULL:
@@ -291,7 +298,7 @@
     }
 
   /* Set up stack. */
-  if (!setup_stack (esp))
+  if (!setup_stack (esp, args))
     goto done;
 
   /* Start address. */
@@ -412,21 +419,109 @@
   return true;
 }
 
+static bool decrement_stack (char **char_esp, void *stackpg, char **tokens,
+                             int d)
+{
+  *char_esp -= d;
+  bool valid_dec =
+      ((uintptr_t) *char_esp >= (uintptr_t) PHYS_BASE - (uintptr_t) PGSIZE);
+  if (!valid_dec)
+    {
+      palloc_free_page (tokens);
+      palloc_free_page (stackpg);
+    }
+  return valid_dec;
+}
+
 /* Create a minimal stack by mapping a zeroed page at the top of
    user virtual memory. */
-static bool setup_stack (void **esp)
+static bool setup_stack (void **esp, const char *filename)
 {
   uint8_t *kpage;
   bool success = false;
+  char *file_name = (char *) filename;
+
+  char **tokens = palloc_get_page (0);
+  if (tokens == NULL)
+    return false;
+  char *save_ptr;
+  const char delimiter[7] = " \t\r\n\f\v";
+  tokens[0] = strtok_r (file_name, delimiter, &save_ptr);
+  int argc = 0;
+  while (tokens[argc])
+    {
+      argc++;
+      if (argc > 128)
+        {
+          return false;
+        }
+      tokens[argc] = strtok_r (NULL, delimiter, &save_ptr);
+    }
 
   kpage = palloc_get_page (PAL_USER | PAL_ZERO);
   if (kpage != NULL)
     {
       success = install_page (((uint8_t *) PHYS_BASE) - PGSIZE, kpage, true);
       if (success)
-        *esp = PHYS_BASE;
+        {
+          *esp = PHYS_BASE;
+          char *char_esp = (char *) *esp;
+          int i = argc - 1;
+          while (i >= 0)
+            {
+              int len = strlen (tokens[i]) + 1;
+              if (!decrement_stack (&char_esp, kpage, tokens, len))
+                {
+                  return false;
+                }
+              memcpy (char_esp, tokens[i], len);
+              i--;
+            }
+
+          char_esp = ALIGN (char_esp); // align down to nearest multiple of 4
+
+          if (!decrement_stack (&char_esp, kpage, tokens, 4))
+            {
+              return false;
+            }
+          int *arg_end = (int *) char_esp;
+          *arg_end = 0;
+
+          i = argc - 1;
+          char *top = *esp;
+          while (i >= 0)
+            {
+              if (!decrement_stack (&char_esp, kpage, tokens, 4))
+                {
+                  return false;
+                }
+              top -= strlen (tokens[i]) + 1;
+              memcpy (char_esp, &top, 4);
+              i--;
+            }
+          char *arg_start = char_esp;
+          if (!decrement_stack (&char_esp, kpage, tokens, 4))
+            {
+              return false;
+            }
+          memcpy (char_esp, &arg_start, 4);
+          if (!decrement_stack (&char_esp, kpage, tokens, 4))
+            {
+              return false;
+            }
+          memcpy (char_esp, &argc, 4);
+          if (!decrement_stack (&char_esp, kpage, tokens, 4))
+            {
+              return false;
+            }
+          *esp = char_esp;
+          palloc_free_page (tokens);
+        }
       else
-        palloc_free_page (kpage);
+        {
+          palloc_free_page (tokens);
+          palloc_free_page (kpage);
+        }
     }
   return success;
 }
diff -ruN aos_pintos/src/userprog/process.h pintos-solution/src/userprog/process.h
--- aos_pintos/src/userprog/process.h	2024-02-29 23:23:00.000000000 +0000
+++ pintos-solution/src/userprog/process.h	2024-03-31 05:11:50.000000000 +0000
@@ -2,7 +2,67 @@
 #define USERPROG_PROCESS_H
 
 #include "threads/thread.h"
+#include "lib/kernel/list.h"
+#include "threads/synch.h"
 
+struct child
+{
+   struct thread* child_thread;
+   struct list_elem elem;
+   struct semaphore exited;
+   int pid;
+   int exit_status;
+};
+
+/* We load ELF binaries.  The following definitions are taken
+   from the ELF specification, [ELF1], more-or-less verbatim.  */
+
+/* ELF types.  See [ELF1] 1-2. */
+typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;
+typedef uint16_t Elf32_Half;
+
+/* For use with ELF types in printf(). */
+#define PE32Wx PRIx32 /* Print Elf32_Word in hexadecimal. */
+#define PE32Ax PRIx32 /* Print Elf32_Addr in hexadecimal. */
+#define PE32Ox PRIx32 /* Print Elf32_Off in hexadecimal. */
+#define PE32Hx PRIx16 /* Print Elf32_Half in hexadecimal. */
+
+/* Executable header.  See [ELF1] 1-4 to 1-8.
+   This appears at the very beginning of an ELF binary. */
+struct Elf32_Ehdr
+{
+  unsigned char e_ident[16];
+  Elf32_Half e_type;
+  Elf32_Half e_machine;
+  Elf32_Word e_version;
+  Elf32_Addr e_entry;
+  Elf32_Off e_phoff;
+  Elf32_Off e_shoff;
+  Elf32_Word e_flags;
+  Elf32_Half e_ehsize;
+  Elf32_Half e_phentsize;
+  Elf32_Half e_phnum;
+  Elf32_Half e_shentsize;
+  Elf32_Half e_shnum;
+  Elf32_Half e_shstrndx;
+};
+
+/* Program header.  See [ELF1] 2-2 to 2-4.
+   There are e_phnum of these, starting at file offset e_phoff
+   (see [ELF1] 1-6). */
+struct Elf32_Phdr
+{
+  Elf32_Word p_type;
+  Elf32_Off p_offset;
+  Elf32_Addr p_vaddr;
+  Elf32_Addr p_paddr;
+  Elf32_Word p_filesz;
+  Elf32_Word p_memsz;
+  Elf32_Word p_flags;
+  Elf32_Word p_align;
+};
+
+bool load (const char *cmdline, void (**eip) (void), void **esp);
 tid_t process_execute (const char *file_name);
 int process_wait (tid_t);
 void process_exit (void);
diff -ruN aos_pintos/src/userprog/syscall.c pintos-solution/src/userprog/syscall.c
--- aos_pintos/src/userprog/syscall.c	2024-02-29 23:23:00.000000000 +0000
+++ pintos-solution/src/userprog/syscall.c	2024-04-30 04:51:58.000000000 +0000
@@ -1,19 +1,670 @@
 #include "userprog/syscall.h"
+#include "userprog/pagedir.h"
 #include <stdio.h>
 #include <syscall-nr.h>
-#include "devices/block.h"
 #include "threads/interrupt.h"
 #include "threads/thread.h"
+#include "threads/vaddr.h"
+#include "threads/malloc.h"
+#include "threads/synch.h"
+#include "userprog/process.h"
+#include "devices/shutdown.h"
+#include "threads/palloc.h"
+#include "threads/malloc.h"
+#include "lib/kernel/stdio.h"
+#include "lib/stdio.h"
+#include "lib/string.h"
+#include "filesys/filesys.h"
+#include "filesys/file.h"
+#include "filesys/inode.h"
+#include "userprog/gdt.h"
+#include "threads/flags.h"
+#include "devices/input.h"
+#include "devices/block.h"
 
+// P2 solution:
 static void syscall_handler (struct intr_frame *);
+static bool valid_ptr (void *);
+
+static struct semaphore filesys_mutex; // Ensure mutual exclusion to filesys
+
+const int MAX_OPEN_FILES = 1024; // Max open files per process
 
 void syscall_init (void)
 {
   intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
+  sema_init (&filesys_mutex, 1);
+}
+
+/* Check if pointers to arguments are valid */
+static int check_args (void *esp, int num_args)
+{
+  int *int_esp = (int *) esp;
+  for (int i = 0; i < num_args; i++)
+    {
+      int_esp += 1;
+      if (!valid_ptr (int_esp))
+        {
+          return 1;
+        }
+    }
+  return 0;
 }
 
 static void syscall_handler (struct intr_frame *f UNUSED)
 {
-  printf ("system call!\n");
+  if (!valid_ptr (f->esp))
+    {
+      exit (-1);
+    }
+  int syscall_num = *(int *) f->esp;
+
+  switch (syscall_num)
+    {
+      case SYS_HALT:
+        halt ();
+        break;
+      case SYS_EXIT:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        int status = *((int *) f->esp + 1);
+        exit (status);
+        break;
+      case SYS_EXEC:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        char *filename = *((char **) f->esp + 1);
+        f->eax = exec (filename);
+        break;
+      case SYS_WAIT:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        pid_t pid = *((pid_t *) f->esp + 1);
+        f->eax = wait (pid);
+        break;
+      case SYS_CREATE:
+        if (check_args (f->esp, 3))
+          {
+            exit (-1);
+          }
+        void *file_c = *((char **) f->esp + 1);
+        unsigned initial_size = *((int *) f->esp + 2);
+        f->eax = create (file_c, initial_size);
+        break;
+      case SYS_REMOVE:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        void *file_r = *((char **) f->esp + 1);
+        f->eax = remove (file_r);
+        break;
+      case SYS_OPEN:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        char *file_o = *((char **) f->esp + 1);
+        f->eax = open (file_o);
+        break;
+      case SYS_FILESIZE:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        unsigned fd_f = *((int *) f->esp + 1);
+        f->eax = filesize (fd_f);
+        break;
+      case SYS_READ:
+        if (check_args (f->esp, 3))
+          {
+            exit (-1);
+          }
+        int fd_r = *((int *) f->esp + 1);
+        void *buffer_r = *((char **) f->esp + 2);
+        unsigned size_r = *((int *) f->esp + 3);
+        f->eax = read (fd_r, buffer_r, size_r);
+        break;
+      case SYS_WRITE:
+        if (check_args (f->esp, 3))
+          {
+            exit (-1);
+          }
+        int fd_w = *((int *) f->esp + 1);
+        void *buffer_w = *((char **) f->esp + 2);
+        unsigned size_w = *((int *) f->esp + 3);
+        f->eax = write (fd_w, buffer_w, size_w);
+        break;
+      case SYS_SEEK:
+        if (check_args (f->esp, 2))
+          {
+            exit (-1);
+          }
+        int fd_s = *((int *) f->esp + 1);
+        unsigned position = *((unsigned *) f->esp + 2);
+        seek (fd_s, position);
+        break;
+      case SYS_TELL:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        int fd_t = *((int *) f->esp + 1);
+        f->eax = tell (fd_t);
+        break;
+      case SYS_CLOSE:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        int fd_c = *((int *) f->esp + 1);
+        close (fd_c);
+        break;
+      case SYS_SYMLINK:
+        if (check_args (f->esp, 2))
+          {
+            exit (-1);
+          }
+        char *target = *((char **) f->esp + 1);
+        char *linkpath = *((char **) f->esp + 2);
+        f->eax = symlink (target, linkpath);
+        break;
+      
+      // P4 tryout:
+      case SYS_CHDIR: // 15
+      if (check_args (f->esp, 1)) {
+        exit (-1);
+      }
+      char *file_cd = *((char **) f->esp + 1);
+      f->eax = chdir (file_cd);
+      break;
+
+    case SYS_MKDIR: // 16
+      if (check_args (f->esp, 1)) {
+        exit (-1);
+      }
+      char *file_m = *((char **) f->esp + 1);
+      f->eax = mkdir (file_m);
+      break;
+
+    case SYS_READDIR: // 17
+      if (check_args (f->esp, 2)) {
+        exit (-1);
+      }
+      int fd_rd = *((int *) f->esp + 1);
+      char *name = *((char **) f->esp + 2);
+      f->eax = readdir (fd_rd, name);
+      break;
+
+    case SYS_ISDIR: // 18
+      if (check_args (f->esp, 1)){
+        exit (-1);
+      }
+      int fd_is = *((int *) f->esp + 1);
+      f->eax = isdir (fd_is);
+      break;
+
+    case SYS_INUMBER: // 19
+      if (check_args (f->esp, 1)){
+        exit (-1);
+      }
+      int fd_in = *((int *) f->esp + 1);
+      f->eax = inumber (fd_in);
+      break;
+    
+    case SYS_STAT:
+      if (check_args (f->esp, 2)) {
+        exit (-1);
+      }
+      char *pathname = *((char **) f->esp + 1);
+      void *buffer_s = *((char **) f->esp + 2);
+      f->eax = stat (pathname, buffer_s);
+      break;
+    }
+}
+
+void halt () { shutdown_power_off (); }
+
+void exit (int status)
+{
+  printf ("%s: exit(%d)\n", thread_current ()->name, status);
+
+  // Free all of exiting thread's children
+  struct list *our_children = &(thread_current ()->children);
+  if (!list_empty (our_children))
+    {
+      struct list_elem *curr;
+      for (curr = list_front (our_children); curr != list_end (our_children);)
+        {
+          struct child *curr_item = list_entry (curr, struct child, elem);
+          curr_item->child_thread->parent = NULL;
+          curr = curr->next;
+          free (curr_item);
+        }
+    }
+
+  // Close all open files
+  int fd = 2;
+  struct file **fds = thread_current ()->fd_table;
+  while (fd < MAX_OPEN_FILES)
+    {
+      if (fds[fd] != NULL)
+        {
+          close (fd);
+        }
+      fd++;
+    }
+
+  /* Find current thread in parents children data structure and communicate exit
+  status */
+  if (thread_current ()->parent)
+    {
+      struct list *children = &(thread_current ()->parent->children);
+      if (!list_empty (children))
+        {
+          struct list_elem *curr;
+          struct child *curr_item;
+          for (curr = list_front (children); curr != list_end (children);
+               curr = list_next (curr))
+            {
+              curr_item = list_entry (curr, struct child, elem);
+              if (curr_item->pid == thread_current ()->tid)
+                {
+                  curr_item->exit_status = status;
+                  // Let waiting parent know you are finished
+                  sema_up (&curr_item->exited);
+                  break;
+                }
+            }
+        }
+    }
+  // Re-enable writes to executable associated w/ this process
+  close (0);
+  palloc_free_page (thread_current ()->fd_table);
   thread_exit ();
-}
\ No newline at end of file
+}
+
+pid_t exec (const char *cmd_line)
+{
+  if (!valid_ptr ((void *) cmd_line))
+    {
+      exit (-1);
+    }
+
+  int tid = process_execute (cmd_line);
+
+  sema_down (&thread_current ()->child_created); // wait for child creation
+  tid = !thread_current ()->success ? -1 : tid;  // if exec fails tid = -1
+  thread_current ()->success = false;            // reset success value
+  return tid;
+}
+
+int wait (pid_t pid) { return process_wait (pid); }
+
+bool create (const char *file, unsigned initial_size)
+{
+  if (!valid_ptr ((void *) file))
+    {
+      exit (-1);
+    }
+
+  sema_down (&filesys_mutex);
+  bool opened = filesys_create (file, initial_size);
+  sema_up (&filesys_mutex);
+
+  return opened;
+}
+
+bool remove (const char *file)
+{
+  if (!valid_ptr ((void *) file))
+    {
+      exit (-1);
+    }
+  sema_down (&filesys_mutex);
+  bool removed = filesys_remove (file);
+  sema_up (&filesys_mutex);
+  return removed;
+}
+
+int open (const char *filename)
+{
+  if (!valid_ptr ((void *) filename))
+    {
+      exit (-1);
+    }
+
+  struct file **fds = thread_current ()->fd_table;
+  int fd = 2;
+  struct file *curr = fds[fd];
+
+  // Find open spot in table to open file
+  while (curr != NULL)
+    {
+      curr = fds[++fd];
+      if (fd == MAX_OPEN_FILES)
+        {
+          return -1;
+        }
+    }
+
+  sema_down (&filesys_mutex);
+  struct file *file = filesys_open (filename);
+  sema_up (&filesys_mutex);
+  if (file == NULL)
+    {
+      return -1;
+    }
+
+  fds[fd] = file;
+  return fd;
+}
+
+int filesize (int fd)
+{
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL)
+    {
+      return 0;
+    }
+  sema_down (&filesys_mutex);
+  int length = file_length (file);
+  sema_up (&filesys_mutex);
+  return length;
+}
+
+int read (int fd, void *buffer, unsigned size)
+{
+  if (fd >= MAX_OPEN_FILES || fd == 1 || fd < 0)
+    {
+      return -1;
+    }
+  if (!valid_ptr ((void *) buffer) || !valid_ptr ((char *) buffer + size))
+    {
+      exit (-1);
+    }
+
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL)
+    {
+      return 0;
+    }
+  unsigned bytes_read = 0;
+
+  // Read from stdin
+  if (fd == 0)
+    {
+      for (unsigned i = 0; i < size; i++)
+        {
+          *((char *) buffer + i) = input_getc ();
+          bytes_read++;
+        }
+    }
+  else // Read from file
+    {
+      sema_down (&filesys_mutex);
+      bytes_read = file_read (file, buffer, size);
+      sema_up (&filesys_mutex);
+    }
+
+  return bytes_read;
+}
+
+int write (int fd, const void *buffer, unsigned size)
+{
+  if (!valid_ptr ((void *) buffer) || !valid_ptr ((char *) buffer + size))
+    {
+      exit (-1);
+    }
+  if (fd >= MAX_OPEN_FILES || fd <= 0)
+    {
+      return 0;
+    }
+  if (fd == 1) // Write to stdout
+    {
+      putbuf (((char *) buffer), (size_t) size);
+      return size;
+    }
+
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL || file->deny_write)
+    {
+      return 0;
+    }
+
+  sema_down (&filesys_mutex);
+  unsigned bytes_written = file_write (file, buffer, size);
+  sema_up (&filesys_mutex);
+  return bytes_written;
+}
+
+void seek (int fd, unsigned position)
+{
+  if (fd >= MAX_OPEN_FILES || fd == 1)
+    {
+      return;
+    }
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL)
+    {
+      return;
+    }
+  sema_down (&filesys_mutex);
+  file_seek (file, position);
+  sema_up (&filesys_mutex);
+}
+
+unsigned tell (int fd)
+{
+  if (fd >= MAX_OPEN_FILES)
+    {
+      return 0;
+    }
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL)
+    {
+      return 0;
+    }
+  sema_down (&filesys_mutex);
+  unsigned pos = file_tell (file);
+  sema_up (&filesys_mutex);
+  return pos;
+}
+
+void close (int fd)
+{
+  struct file **fds = thread_current ()->fd_table;
+  if (fd >= MAX_OPEN_FILES)
+    {
+      return;
+    }
+  sema_down (&filesys_mutex);
+  file_close (fds[fd]);
+  fds[fd] = NULL;
+  sema_up (&filesys_mutex);
+}
+
+int symlink (char *target, char *linkpath)
+{
+  sema_down (&filesys_mutex);
+  struct file *target_file = filesys_open (target);
+  sema_up (&filesys_mutex);
+
+  if (target_file == NULL)
+    {
+      return -1;
+    }
+
+  sema_down (&filesys_mutex);
+  bool success = filesys_symlink (target, linkpath);
+  sema_up (&filesys_mutex);
+
+  return success ? 0 : -1;
+}
+
+bool valid_ptr (void *ptr)
+{
+  return ptr && !is_kernel_vaddr (ptr) &&
+         pagedir_get_page (thread_current ()->pagedir, ptr);
+}
+
+
+// P4 tryout:
+/* System Call: bool chdir (const char *dir) */
+bool chdir (const char *dir)
+{
+  if (!valid_ptr ((void *) dir)) {
+    return false;
+  }
+
+  // sema_down (&filesys_mutex);
+  // bool ret = filesys_chdir (dir);
+  // // if (directory == NULL) {
+  // //   sema_up (&filesys_mutex);
+  // //   return false;
+  // // }
+
+  // // struct thread *cur = thread_current ();
+  // // dir_close (cur->cwd);  // Close the current working directory
+  // // cur->cwd = directory;  // Update the current working directory
+  // sema_up (&filesys_mutex);
+
+  return true;
+}
+
+/* System Call: bool mkdir (const char *dir) */
+bool mkdir (const char *dir)
+{
+  if (!valid_ptr ((void *) dir)) {
+    return false;
+  }
+  
+  // sema_down (&filesys_mutex);
+  // bool ret = filesys_create (dir, 0, true);
+  // sema_up (&filesys_mutex);
+
+  return true;
+}
+
+/* System Call: bool readdir (int fd, char *name) */
+bool readdir (int fd, char *name)
+{
+  if (fd < 3 || fd >= MAX_OPEN_FILES || name == NULL || !valid_ptr (name)) {
+    return false;
+  }
+
+  sema_down (&filesys_mutex);
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL) {
+    sema_up (&filesys_mutex);
+    return false;
+  }
+
+  // struct inode *inode = file_get_inode(file);
+  // if(inode == NULL) {
+  //   sema_up (&filesys_mutex);
+  //   return false;
+  // }
+
+  // if(! inode_is_dir(inode)) {
+  //   sema_up (&filesys_mutex);
+  //   return false;
+  // }
+
+  // struct dir *dir = dir_open (inode);
+  // if (dir == NULL) {
+  //   sema_up (&filesys_mutex);
+  //   return false;
+  // }
+
+  // bool success = dir_readdir (dir, name);
+  // // dir_close (dir);
+  sema_up (&filesys_mutex);
+
+  return true;
+}
+
+/* System Call: bool isdir (int fd) */
+bool isdir (int fd)
+{
+  if (fd < 3 || fd >= MAX_OPEN_FILES) {
+    return false;
+  }
+
+  sema_down (&filesys_mutex);
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL) {
+    sema_up (&filesys_mutex);
+    return false;
+  }
+  
+  // bool ret = inode_is_dir (file_get_inode (file));
+  sema_up (&filesys_mutex);
+
+  return true;
+}
+
+/* System Call: int inumber (int fd) */
+int inumber (int fd)
+{
+  if (fd < 3 || fd >= MAX_OPEN_FILES) {
+    return -1;
+  }
+
+  sema_down (&filesys_mutex);
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL) {
+    sema_up (&filesys_mutex);
+    return -1;
+  }
+  
+  // int ret = (int) inode_get_inumber (file_get_inode (file));
+  sema_up (&filesys_mutex);
+
+  return 0;
+}
+
+/* System Call: int stat (char *pathname, void *buf) */
+int stat(const char *pathname, void *buf)
+{
+    struct stat *stat_buf;
+    struct inode *inode;
+    int result = -1; // Default error return value
+
+    /* Check if the buffer pointer is valid */
+    if (!valid_ptr ((void *) buf) || !valid_ptr ((char *) buf + sizeof(struct stat))) {
+        return -1;
+    }
+
+    /* Allocate memory for the stat structure */
+    sema_down (&filesys_mutex);
+    stat_buf = (struct stat *)malloc(sizeof(struct stat));
+    if (stat_buf == NULL) {
+        sema_up (&filesys_mutex);
+        return -1; // Memory allocation failed
+    }
+
+    /* Open the inode corresponding to the pathname */
+    // inode = filesys_open_inode(pathname);
+    // if (inode != NULL)
+    // {
+    //     /* Fill the stat structure with inode information */
+    //     stat_buf->logical_size = inode_length(inode);
+    //     stat_buf->physical_size = inode_length_physical(inode);
+    //     stat_buf->inode_number = inode_get_inumber(inode);
+    //     stat_buf->blocks = inode_get_blocks(inode);
+
+    //     /* Copy the stat structure to the user-provided buffer */
+    //     memcpy(buf, stat_buf, sizeof(struct stat));
+    // }
+
+    free(stat_buf); // Free allocated memory
+    sema_up (&filesys_mutex);
+    return result;
+}
diff -ruN aos_pintos/src/userprog/syscall.h pintos-solution/src/userprog/syscall.h
--- aos_pintos/src/userprog/syscall.h	2024-02-29 23:23:00.000000000 +0000
+++ pintos-solution/src/userprog/syscall.h	2024-04-30 04:48:45.000000000 +0000
@@ -3,6 +3,28 @@
 
 #include <stdbool.h>
 
+typedef int pid_t;
 void syscall_init (void);
+void halt (void);
+void exit (int);
+pid_t exec (const char *);
+int wait (pid_t);
+bool create (const char *, unsigned);
+bool remove (const char *);
+int open (const char *);
+int filesize (int);
+int read (int, void *, unsigned);
+int write (int, const void *, unsigned);
+void seek (int, unsigned);
+unsigned tell (int);
+void close (int);
+int symlink (char *, char *);
+
+bool chdir (const char *dir);
+bool mkdir (const char *dir);
+bool readdir (int fd, char *name);
+bool isdir (int fd);
+int inumber (int fd);
+int stat (const char *pathname, void *buf);
 
 #endif /* userprog/syscall.h */
