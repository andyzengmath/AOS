diff -ruN aos_pintos/src/devices/block.h pintos-solution/src/devices/block.h
--- aos_pintos/src/devices/block.h	2024-02-09 01:26:32.387938982 +0000
+++ pintos-solution/src/devices/block.h	2024-03-31 05:11:50.000000000 +0000
@@ -30,7 +30,7 @@
   BLOCK_FILESYS, /* File system. */
   BLOCK_SCRATCH, /* Scratch. */
   BLOCK_SWAP,    /* Swap. */
-  BLOCK_ROLE_CNT,
+  BLOCK_ROLE_CNT, // [placeholder] - it is turtles all the way down
 
   /* Other kinds of block devices that Pintos may see but does
      not interact with. */
diff -ruN aos_pintos/src/filesys/directory.c pintos-solution/src/filesys/directory.c
--- aos_pintos/src/filesys/directory.c	2024-02-09 01:26:32.047953955 +0000
+++ pintos-solution/src/filesys/directory.c	2024-04-30 04:36:05.000000000 +0000
@@ -6,6 +6,8 @@
 #include "filesys/inode.h"
 #include "threads/malloc.h"
 
+// P2 solution code:
+
 /* A directory. */
 struct dir
 {
@@ -219,3 +221,369 @@
     }
   return false;
 }
+
+// P4 try out:
+
+// void
+// split_path_filename(const char *path,
+//     char *directory, char *filename)
+// {
+//   int l = strlen(path);
+//   char *s = (char*) malloc( sizeof(char) * (l + 1) );
+//   memcpy (s, path, sizeof(char) * (l + 1));
+
+//   // absolute path handling
+//   char *dir = directory;
+//   if(l > 0 && path[0] == '/') {
+//     if(dir) *dir++ = '/';
+//   }
+
+//   // tokenize
+//   char *token, *p, *last_token = "";
+//   for (token = strtok_r(s, "/", &p); token != NULL;
+//        token = strtok_r(NULL, "/", &p))
+//   {
+//     // append last_token into directory
+//     int tl = strlen (last_token);
+//     if (dir && tl > 0) {
+//       memcpy (dir, last_token, sizeof(char) * tl);
+//       dir[tl] = '/';
+//       dir += tl + 1;
+//     }
+
+//     last_token = token;
+//   }
+
+//   if(dir) *dir = '\0';
+//   memcpy (filename, last_token, sizeof(char) * (strlen(last_token) + 1));
+//   free (s);
+
+// }
+
+// /* Creates a directory with space for ENTRY_CNT entries in the
+//    given SECTOR.  Returns true if successful, false on failure. */
+// bool dir_create (block_sector_t sector, size_t entry_cnt)
+// {
+//   // return inode_create_2 (sector, entry_cnt * sizeof (struct dir_entry), true);
+//   // return inode_create (sector, entry_cnt * sizeof (struct dir_entry), /*is_dir*/ true);
+//   bool success = true;
+//   success = inode_create (sector, entry_cnt * sizeof (struct dir_entry), /*is_dir*/ true);
+//   if(!success) return false;
+
+//   // The first (offset 0) dir entry is for parent directory; do self-referencing
+//   // Actual parent directory will be set on execution of dir_add()
+//   struct dir *dir = dir_open( inode_open(sector) );
+//   ASSERT (dir != NULL);
+//   struct dir_entry e;
+//   e.inode_sector = sector;
+//   if (inode_write_at(dir->inode, &e, sizeof e, 0) != sizeof e) {
+//     success = false;
+//   }
+//   dir_close (dir);
+
+//   return success;
+// }
+
+// /* Opens and returns the directory for the given INODE, of which
+//    it takes ownership.  Returns a null pointer on failure. */
+// struct dir *dir_open (struct inode *inode)
+// {
+//   struct dir *dir = calloc (1, sizeof *dir);
+//   if (inode != NULL && dir != NULL)
+//     {
+//       dir->inode = inode;
+//       // dir->pos = 0;
+//       dir->pos = sizeof (struct dir_entry); // 0-pos is for parent directory
+//       return dir;
+//     }
+//   else
+//     {
+//       inode_close (inode);
+//       free (dir);
+//       return NULL;
+//     }
+// }
+
+// /* Opens the root directory and returns a directory for it.
+//    Return true if successful, false on failure. */
+// struct dir *dir_open_root (void)
+// {
+//   return dir_open (inode_open (ROOT_DIR_SECTOR));
+// }
+
+// /* Opens the directory for given path. */
+// struct dir *
+// dir_open_path (const char *path)
+// {
+//   // copy of path, to tokenize
+//   int l = strlen(path);
+//   char s[l + 1];
+//   strlcpy(s, path, l + 1);
+
+//   // relative path handling
+//   struct dir *curr;
+//   if(path[0] == '/') { // absolute path
+//     curr = dir_open_root();
+//   }
+//   else { // relative path
+//     struct thread *t = thread_current();
+//     if (t->cwd == NULL) // may happen for non-process threads (e.g. main)
+//       curr = dir_open_root();
+//     else {
+//       curr = dir_reopen( t->cwd );
+//     }
+//   }
+
+//   // tokenize, and traverse the tree
+//   char *token, *p;
+//   for (token = strtok_r(s, "/", &p); token != NULL;
+//        token = strtok_r(NULL, "/", &p))
+//   {
+//     struct inode *inode = NULL;
+//     if(! dir_lookup(curr, token, &inode)) {
+//       dir_close(curr);
+//       return NULL; // such directory not exist
+//     }
+
+//     struct dir *next = dir_open(inode);
+//     if(next == NULL) {
+//       dir_close(curr);
+//       return NULL;
+//     }
+//     dir_close(curr);
+//     curr = next;
+//   }
+
+//   // prevent from opening removed directories
+//   if (inode_is_removed (dir_get_inode(curr))) {
+//     dir_close(curr);
+//     return NULL;
+//   }
+
+
+//   return curr;
+// }
+
+// /* Opens and returns a new directory for the same inode as DIR.
+//    Returns a null pointer on failure. */
+// struct dir *dir_reopen (struct dir *dir)
+// {
+//   return dir_open (inode_reopen (dir->inode));
+// }
+
+// /* Destroys DIR and frees associated resources. */
+// void dir_close (struct dir *dir)
+// {
+//   if (dir != NULL)
+//     {
+//       inode_close (dir->inode);
+//       free (dir);
+//     }
+// }
+
+// /* Returns the inode encapsulated by DIR. */
+// struct inode *dir_get_inode (struct dir *dir) { return dir->inode; }
+
+// /* Searches DIR for a file with the given NAME.
+//    If successful, returns true, sets *EP to the directory entry
+//    if EP is non-null, and sets *OFSP to the byte offset of the
+//    directory entry if OFSP is non-null.
+//    otherwise, returns false and ignores EP and OFSP. */
+// static bool lookup (const struct dir *dir, const char *name,
+//                     struct dir_entry *ep, off_t *ofsp)
+// {
+//   struct dir_entry e;
+//   size_t ofs;
+
+//   ASSERT (dir != NULL);
+//   ASSERT (name != NULL);
+
+//   // for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//   for (ofs = sizeof e; /* 0-pos is for parent directory */
+//        inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//        ofs += sizeof e)
+//     if (e.in_use && !strcmp (name, e.name))
+//       {
+//         if (ep != NULL)
+//           *ep = e;
+//         if (ofsp != NULL)
+//           *ofsp = ofs;
+//         return true;
+//       }
+//   return false;
+// }
+
+// /* Searches DIR for a file with the given NAME
+//    and returns true if one exists, false otherwise.
+//    On success, sets *INODE to an inode for the file, otherwise to
+//    a null pointer.  The caller must close *INODE. */
+// bool dir_lookup (const struct dir *dir, const char *name, struct inode **inode)
+// {
+//   struct dir_entry e;
+
+//   ASSERT (dir != NULL);
+//   ASSERT (name != NULL);
+
+//   // if (lookup (dir, name, &e, NULL))
+//   if (strcmp (name, ".") == 0) {
+//     // current directory
+//     *inode = inode_reopen (dir->inode);
+//   }
+//   else if (strcmp (name, "..") == 0) {
+//     // parent directory : the information is stored at the first (0-pos) entry.
+//     inode_read_at (dir->inode, &e, sizeof e, 0);
+//     *inode = inode_open (e.inode_sector);
+//   }
+//   else if (lookup (dir, name, &e, NULL)) {
+//     // normal lookup. lookuped entry is stored into e
+//     *inode = inode_open (e.inode_sector);
+//   }
+//   else
+//     *inode = NULL;
+
+//   return *inode != NULL;
+// }
+
+// /* Adds a file named NAME to DIR, which must not already contain a
+//    file by that name.  The file's inode is in sector
+//    INODE_SECTOR.
+//    Returns true if successful, false on failure.
+//    Fails if NAME is invalid (i.e. too long) or a disk or memory
+//    error occurs. */
+// // bool dir_add (struct dir *dir, const char *name, block_sector_t inode_sector)
+// bool dir_add (struct dir *dir, const char *name, block_sector_t inode_sector, bool is_dir)
+
+// {
+//   struct dir_entry e;
+//   off_t ofs;
+//   bool success = false;
+
+//   ASSERT (dir != NULL);
+//   ASSERT (name != NULL);
+
+//   /* Check NAME for validity. */
+//   if (*name == '\0' || strlen (name) > NAME_MAX)
+//     return false;
+
+//   /* Check that NAME is not in use. */
+//   if (lookup (dir, name, NULL, NULL))
+//     goto done;
+  
+//   // update the child directory [inode_sector] has a parent directory [dir]
+//   if (is_dir)
+//   {
+//     /* e is a parent-directory-entry here */
+//     struct dir *child_dir = dir_open( inode_open(inode_sector) );
+//     if(child_dir == NULL) goto done;
+//     e.inode_sector = inode_get_inumber( dir_get_inode(dir) );
+//     if (inode_write_at(child_dir->inode, &e, sizeof e, 0) != sizeof e) {
+//       dir_close (child_dir);
+//       goto done;
+//     }
+//     dir_close (child_dir);
+//   }
+
+//   /* Set OFS to offset of free slot.
+//      If there are no free slots, then it will be set to the
+//      current end-of-file.
+
+//      inode_read_at() will only return a short read at end of file.
+//      Otherwise, we'd need to verify that we didn't get a short
+//      read due to something intermittent such as low memory. */
+//   for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//        ofs += sizeof e)
+//     if (!e.in_use)
+//       break;
+
+//   /* Write slot. */
+//   e.in_use = true;
+//   strlcpy (e.name, name, sizeof e.name);
+//   e.inode_sector = inode_sector;
+//   success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+
+// done:
+//   return success;
+// }
+
+// /* Removes any entry for NAME in DIR.
+//    Returns true if successful, false on failure,
+//    which occurs only if there is no file with the given NAME. */
+// bool dir_remove (struct dir *dir, const char *name)
+// {
+//   struct dir_entry e;
+//   struct inode *inode = NULL;
+//   bool success = false;
+//   off_t ofs;
+
+//   ASSERT (dir != NULL);
+//   ASSERT (name != NULL);
+
+//   /* Find directory entry. */
+//   if (!lookup (dir, name, &e, &ofs))
+//     goto done;
+
+//   /* Open inode. */
+//   inode = inode_open (e.inode_sector);
+//   if (inode == NULL)
+//     goto done;
+  
+//   /* Prevent removing non-empty directory. */
+//   if (inode_is_dir (inode)) {
+//     // target : the directory to be removed. (dir : the base directory)
+//     struct dir *target = dir_open (inode);
+//     bool is_empty = dir_is_empty (target);
+//     dir_close (target);
+//     if (! is_empty) goto done; // can't delete
+//   }
+
+//   /* Erase directory entry. */
+//   e.in_use = false;
+//   if (inode_write_at (dir->inode, &e, sizeof e, ofs) != sizeof e)
+//     goto done;
+
+//   /* Remove inode. */
+//   inode_remove (inode);
+//   success = true;
+
+// done:
+//   inode_close (inode);
+//   return success;
+// }
+
+// /* Reads the next directory entry in DIR and stores the name in
+//    NAME.  Returns true if successful, false if the directory
+//    contains no more entries. */
+// bool dir_readdir (struct dir *dir, char name[NAME_MAX + 1])
+// {
+//   struct dir_entry e;
+
+//   while (inode_read_at (dir->inode, &e, sizeof e, dir->pos) == sizeof e)
+//     {
+//       dir->pos += sizeof e;
+//       if (e.in_use)
+//         {
+//           strlcpy (name, e.name, NAME_MAX + 1);
+//           return true;
+//         }
+//     }
+//   return false;
+// }
+
+// /* Returns whether the DIR is empty. */
+// bool
+// dir_is_empty (const struct dir *dir)
+// {
+//   struct dir_entry e;
+//   off_t ofs;
+
+//   // for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//   for (ofs = sizeof e; /* 0-pos is for parent directory */
+//        inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+//        ofs += sizeof e)
+//   {
+//     if (e.in_use)
+//       return false;
+//   }
+//   return true;
+// }
+
diff -ruN aos_pintos/src/filesys/directory.h pintos-solution/src/filesys/directory.h
--- aos_pintos/src/filesys/directory.h	2024-02-09 01:26:32.075952722 +0000
+++ pintos-solution/src/filesys/directory.h	2024-04-30 04:34:42.000000000 +0000
@@ -27,4 +27,11 @@
 bool dir_remove (struct dir *, const char *name);
 bool dir_readdir (struct dir *, char name[NAME_MAX + 1]);
 
+// /* Directory and Path manipulation utilities. */
+// void split_path_filename(const char *path, char *directory, char *filename);
+// bool dir_add (struct dir *, const char *name, block_sector_t, bool is_dir);
+// bool dir_is_empty (const struct dir *);
+// struct dir *dir_open_path(const char *path);
+
+
 #endif /* filesys/directory.h */
diff -ruN aos_pintos/src/filesys/file.c pintos-solution/src/filesys/file.c
--- aos_pintos/src/filesys/file.c	2024-02-09 01:26:32.083952370 +0000
+++ pintos-solution/src/filesys/file.c	2024-04-30 04:37:48.000000000 +0000
@@ -142,4 +142,238 @@
 {
   ASSERT (file != NULL);
   return file->pos;
-}
\ No newline at end of file
+}
+
+// P4 Tryout:
+
+// /* Opens a file for the given INODE, of which it takes ownership,
+//    and returns the new file.  Returns a null pointer if an
+//    allocation fails or if INODE is null. */
+// struct file *file_open (struct inode *inode)
+// {
+//   struct file *file = calloc (1, sizeof *file);
+//   if (inode != NULL && file != NULL)
+//     {
+//       file->inode = inode;
+//       file->pos = 0;
+//       file->deny_write = false;
+//       return file;
+//     }
+//   else
+//     {
+//       inode_close (inode);
+//       free (file);
+//       return NULL;
+//     }
+// }
+
+// /* Opens and returns a new file for the same inode as FILE.
+//    Returns a null pointer if unsuccessful. */
+// struct file *file_reopen (struct file *file)
+// {
+//   return file_open (inode_reopen (file->inode));
+// }
+
+// /* Closes FILE. */
+// void file_close (struct file *file)
+// {
+//   if (file != NULL)
+//     {
+//       file_allow_write (file);
+//       inode_close (file->inode);
+//       free (file);
+//     }
+// }
+
+// /* Returns the inode encapsulated by FILE. */
+// struct inode *file_get_inode (struct file *file) { return file->inode; }
+
+// /* Reads SIZE bytes from FILE into BUFFER,
+//    starting at the file's current position.
+//    Returns the number of bytes actually read,
+//    which may be less than SIZE if end of file is reached.
+//    Advances FILE's position by the number of bytes read. */
+// off_t file_read (struct file *file, void *buffer, off_t size)
+// {
+//   off_t bytes_read = inode_read_at (file->inode, buffer, size, file->pos);
+//   file->pos += bytes_read;
+//   return bytes_read;
+// }
+
+// /* Reads SIZE bytes from FILE into BUFFER,
+//    starting at offset FILE_OFS in the file.
+//    Returns the number of bytes actually read,
+//    which may be less than SIZE if end of file is reached.
+//    The file's current position is unaffected. */
+// off_t file_read_at (struct file *file, void *buffer, off_t size, off_t file_ofs)
+// {
+//   return inode_read_at (file->inode, buffer, size, file_ofs);
+// }
+
+// /* Writes SIZE bytes from BUFFER into FILE,
+//    starting at the file's current position.
+//    Returns the number of bytes actually written,
+//    which may be less than SIZE if end of file is reached.
+//    (Normally we'd grow the file in that case, but file growth is
+//    not yet implemented.)
+//    Advances FILE's position by the number of bytes read. */
+// // off_t file_write (struct file *file, const void *buffer, off_t size)
+// // {
+// //   off_t bytes_written = inode_write_at (file->inode, buffer, size, file->pos);
+// //   file->pos += bytes_written;
+// //   return bytes_written;
+// // }
+
+// off_t file_write(struct file *file, const void *buffer, off_t size) {
+//     off_t bytes_written = inode_write_at(file->inode, buffer, size, file->pos);
+//     file->pos += bytes_written;
+
+//     // Handle file growth if writing past EOF
+//     off_t end_pos = file_length(file);
+//     if (file->pos > end_pos) {
+//         off_t zero_fill_size = file->pos - end_pos;
+//         char zeros[zero_fill_size];
+//         memset(zeros, 0, zero_fill_size);
+//         bytes_written += inode_write_at(file->inode, zeros, zero_fill_size, end_pos);
+//         file->pos += zero_fill_size;
+//     }
+
+//     return bytes_written;
+// }
+
+
+
+// /* Writes SIZE bytes from BUFFER into FILE,
+//    starting at offset FILE_OFS in the file.
+//    Returns the number of bytes actually written,
+//    which may be less than SIZE if end of file is reached.
+//    (Normally we'd grow the file in that case, but file growth is
+//    not yet implemented.)
+//    The file's current position is unaffected. */
+// off_t file_write_at(struct file *file, const void *buffer, off_t size, off_t file_ofs)
+// {
+//   if (file->deny_write)
+//     return 0;
+
+//   off_t bytes_written = 0;
+
+//   while (size > 0)
+//   {
+//     /* Sector to write, starting byte offset within sector. */
+//     block_sector_t sector_idx = byte_to_sector(file->inode, file_ofs);
+//     if (sector_idx == (block_sector_t)-1)
+//       break;
+
+//     int sector_ofs = file_ofs % BLOCK_SECTOR_SIZE;
+
+//     /* Number of bytes left in this sector. */
+//     int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
+
+//     /* Number of bytes to write into this sector. */
+//     int chunk_size = size < sector_left ? size : sector_left;
+
+//     if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
+//     {
+//       /* Write full sector directly to disk. */
+//       // block_write(fs_device, sector_idx, buffer + bytes_written);
+//       block_write(fs_device, (block_sector_t)sector_idx, (uint8_t *)buffer + bytes_written);
+//     }
+//     else
+//     {
+//       /* We need a bounce buffer. */
+//       void *bounce = malloc(BLOCK_SECTOR_SIZE);
+//       if (bounce == NULL)
+//         break;
+
+//       /* If the sector contains data before or after the chunk
+//          we're writing, then we need to read in the sector
+//          first.  Otherwise we start with a sector of all zeros. */
+//       if (sector_ofs > 0 || chunk_size < sector_left)
+//         block_read(fs_device, sector_idx, bounce);
+//       else
+//         memset(bounce, 0, BLOCK_SECTOR_SIZE);
+//       // memcpy(bounce + sector_ofs, buffer + bytes_written, chunk_size);
+//       memcpy((uint8_t *)bounce + sector_ofs, (uint8_t *)buffer + bytes_written, chunk_size);
+
+//       block_write(fs_device, sector_idx, bounce);
+
+//       free(bounce);
+//     }
+
+//     /* Advance. */
+//     size -= chunk_size;
+//     file_ofs += chunk_size;
+//     bytes_written += chunk_size;
+//   }
+
+//   if (file_ofs > file->inode->data.length)
+//   {
+//     file->inode->data.length = file_ofs;
+//     block_write(fs_device, file->inode->sector, &file->inode->data);
+//   }
+
+//   return bytes_written;
+// }
+
+
+// /* Prevents write operations on FILE's underlying inode
+//    until file_allow_write() is called or FILE is closed. */
+// void file_deny_write (struct file *file)
+// {
+//   ASSERT (file != NULL);
+//   if (!file->deny_write)
+//     {
+//       file->deny_write = true;
+//       inode_deny_write (file->inode);
+//     }
+// }
+
+// /* Re-enables write operations on FILE's underlying inode.
+//    (Writes might still be denied by some other file that has the
+//    same inode open.) */
+// void file_allow_write (struct file *file)
+// {
+//   ASSERT (file != NULL);
+//   if (file->deny_write)
+//     {
+//       file->deny_write = false;
+//       inode_allow_write (file->inode);
+//     }
+// }
+
+// /* Returns the size of FILE in bytes. */
+// off_t file_length (struct file *file)
+// {
+//   if (file == NULL)
+//     return -1;
+
+//   off_t file_size = inode_length (file->inode);
+
+//   // Adjust file size for sparse files by considering the actual data
+//   off_t pos_backup = file->pos;
+//   file->pos = file_size; // Move file position to EOF
+//   char temp; // Dummy variable to read 1 byte
+//   if (file_read (file, &temp, 1) == 0)
+//     file_size = file->pos; // Update file size based on actual EOF
+//   file->pos = pos_backup; // Restore original file position
+
+//   return file_size;
+// }
+
+// /* Sets the current position in FILE to NEW_POS bytes from the
+//    start of the file. */
+// void file_seek (struct file *file, off_t new_pos)
+// {
+//   ASSERT (file != NULL);
+//   ASSERT (new_pos >= 0);
+//   file->pos = new_pos;
+// }
+
+
+// /* Returns the current position in FILE as a byte offset from the
+//    start of the file. */
+// off_t file_tell (struct file *file)
+// {
+//   ASSERT (file != NULL);
+//   return file->pos;
+// }
\ No newline at end of file
diff -ruN aos_pintos/src/filesys/file.h pintos-solution/src/filesys/file.h
--- aos_pintos/src/filesys/file.h	2024-02-09 01:26:32.063953250 +0000
+++ pintos-solution/src/filesys/file.h	2024-04-30 04:36:31.000000000 +0000
@@ -12,6 +12,7 @@
   struct inode *inode; /* File's inode. */
   off_t pos;           /* Current position. */
   bool deny_write;     /* Has file_deny_write() been called? */
+  // struct dir* dir;
 };
 
 /* Opening and closing files. */
diff -ruN aos_pintos/src/filesys/filesys.c pintos-solution/src/filesys/filesys.c
--- aos_pintos/src/filesys/filesys.c	2024-02-09 01:26:32.063953250 +0000
+++ pintos-solution/src/filesys/filesys.c	2024-04-30 04:41:58.000000000 +0000
@@ -7,6 +7,7 @@
 #include "filesys/inode.h"
 #include "filesys/directory.h"
 
+// P2 solution:
 /* Partition that contains the file system. */
 struct block *fs_device;
 
@@ -120,4 +121,169 @@
     PANIC ("root directory creation failed");
   free_map_close ();
   printf ("done.\n");
-}
\ No newline at end of file
+}
+
+// P4 tryout:
+
+// /* Creates a file named NAME with the given INITIAL_SIZE.
+//    Returns true if successful, false otherwise.
+//    Fails if a file named NAME already exists,
+//    or if internal memory allocation fails. */
+// bool filesys_create (const char *name, off_t initial_size, bool is_dir)
+// {
+//   block_sector_t inode_sector = 0;
+//   // struct dir *dir = dir_open_root ();
+//   // split path and name
+//   char directory[ strlen(name) ];
+//   char file_name[ strlen(name) ];
+//   split_path_filename(name, directory, file_name);
+//   struct dir *dir = dir_open_path (directory);
+
+//   bool success = (dir != NULL && free_map_allocate (1, &inode_sector)
+//                   && inode_create (inode_sector, initial_size, is_dir)
+//                   && dir_add (dir, file_name, inode_sector, is_dir));
+//   if (!success && inode_sector != 0)
+//     free_map_release (inode_sector, 1);
+
+//   dir_close (dir);
+
+//   return success;
+// }
+
+// /* Opens the file with the given NAME.
+//    Returns the new file if successful or a null pointer
+//    otherwise.
+//    Fails if no file named NAME exists,
+//    or if an internal memory allocation fails. */
+// struct file *filesys_open(const char *name) {
+//   // struct dir *dir = dir_open_root();
+//   // char directory[ strlen(name) ];
+//   // char file_name[ strlen(name) ];
+//   int l = strlen(name);
+//   if (l == 0) return NULL;
+
+//   char directory[ l + 1 ];
+//   char file_name[ l + 1 ];
+//   split_path_filename(name, directory, file_name);
+//   struct dir *dir = dir_open_path (directory);
+
+//   struct inode *inode = NULL;
+
+//   // removed directory handling
+//   if (dir == NULL) return NULL;
+
+//   if (strlen(file_name) > 0) {
+//     dir_lookup (dir, file_name, &inode);
+//     dir_close (dir);
+//   } else { // empty filename : just return the directory
+//     inode = dir_get_inode (dir);
+//   }
+
+//   // removed file handling
+//   if (inode == NULL || inode_is_removed (inode))
+//     return NULL;
+
+//   if (inode_get_symlink(inode)) {
+//     char target[NAME_MAX + 1];
+//     inode_read_at(inode, target, NAME_MAX + 1, 0);
+//     return filesys_open(target); // Recursively open the target of the symbolic link
+//   }
+
+//   return file_open(inode);
+// }
+
+
+// /* Deletes the file named NAME.
+//    Returns true if successful, false on failure.
+//    Fails if no file named NAME exists,
+//    or if an internal memory allocation fails. */
+// bool filesys_remove (const char *name)
+// {
+//   // struct dir *dir = dir_open_root ();
+//   // bool success = dir != NULL && dir_remove (dir, name);
+//   char directory[ strlen(name) ];
+//   char file_name[ strlen(name) ];
+//   split_path_filename(name, directory, file_name);
+//   struct dir *dir = dir_open_path (directory);
+
+//   bool success = (dir != NULL && dir_remove (dir, file_name));
+//   dir_close (dir);
+
+//   return success;
+// }
+
+// /* Creates symbolic link LINKPATH to target file TARGET
+//    Returns true if symbolic link created successfully,
+//    false otherwise. */
+// bool filesys_symlink (char *target, char *linkpath)
+// {
+//   ASSERT (target != NULL && linkpath != NULL);
+//   bool success = filesys_create (linkpath, 15, false);
+//   struct file *symlink = filesys_open (linkpath);
+//   inode_set_symlink (file_get_inode (symlink), true);
+//   inode_write_at (file_get_inode (symlink), target, NAME_MAX + 1, 0);
+//   file_close (symlink);
+//   return success;
+// }
+
+// /* Formats the file system. */
+// static void do_format (void)
+// {
+//   printf ("Formatting file system...");
+//   free_map_create ();
+//   if (!dir_create (ROOT_DIR_SECTOR, 16))
+//     PANIC ("root directory creation failed");
+//   free_map_close ();
+//   printf ("done.\n");
+// }
+
+// bool valid_filename(const char *name) {
+//     if (name == NULL) {
+//         return false;  // NULL filename is invalid
+//     }
+
+//     while (*name != '\0') {
+//         if (*name == '/') {
+//             return false;  // '/' character found, invalid filename
+//         }
+//         name++;
+//     }
+
+//     return true;  // No invalid characters found, filename is valid
+// }
+
+// /* Open a directory given its name. */
+// struct dir *filesys_open_dir (const char *name)
+// {
+//   if (!valid_filename (name) || strchr (name, '/') != NULL)
+//     return NULL;
+
+//   struct dir *dir = dir_open_path (name);
+//   return dir;
+// }
+
+// /* Open an inode given its path. */
+// struct inode *filesys_open_inode (const char *name)
+// {
+//   if (!valid_filename (name))
+//     return NULL;
+
+//   struct inode *inode = inode_open_path (name);
+//   return inode;
+// }
+
+// /* Change CWD for the current thread. */
+// bool
+// filesys_chdir (const char *name)
+// {
+//   struct dir *dir = dir_open_path (name);
+
+//   if(dir == NULL) {
+//     return false;
+//   }
+
+//   // switch CWD
+//   dir_close (thread_current()->cwd);
+//   thread_current()->cwd = dir;
+//   return true;
+// }
diff -ruN aos_pintos/src/filesys/filesys.h pintos-solution/src/filesys/filesys.h
--- aos_pintos/src/filesys/filesys.h	2024-02-09 01:26:32.059953426 +0000
+++ pintos-solution/src/filesys/filesys.h	2024-04-30 04:40:36.000000000 +0000
@@ -2,7 +2,9 @@
 #define FILESYS_FILESYS_H
 
 #include <stdbool.h>
+#include <stddef.h>
 #include "filesys/off_t.h"
+#include "devices/block.h"
 
 /* Sectors of system file inodes. */
 #define FREE_MAP_SECTOR 0 /* Free map file inode sector. */
@@ -11,6 +13,18 @@
 /* Block device that contains the file system. */
 extern struct block *fs_device;
 
+/* Count of allocated blocks. */
+typedef uint32_t blkcnt_t;
+
+/* Struct containing file status. */
+struct stat
+{
+    size_t logical_size;            /* The logical file size of a file. */
+    size_t physical_size;           /* The physical file size of a file. */
+    block_sector_t inode_number;    /* The inode number of a file. */
+    blkcnt_t blocks;                /* Number of blocks allocated. */
+};
+
 void filesys_init (bool format);
 void filesys_done (void);
 bool filesys_create (const char *name, off_t initial_size);
@@ -20,4 +34,12 @@
 /* Symbolic link creation */
 bool filesys_symlink (char *target, char *linkpath);
 
+// P4 tryout:
+// bool filesys_create (const char *name, off_t initial_size, bool is_dir);
+// bool filesys_create_dir (const char *name);
+// struct dir *filesys_open_dir (const char *name);
+// struct inode *filesys_open_inode (const char *name);
+// bool filesys_chdir (const char *name);
+// bool valid_filename(const char *name);
+
 #endif /* filesys/filesys.h */
diff -ruN aos_pintos/src/filesys/free-map.c pintos-solution/src/filesys/free-map.c
--- aos_pintos/src/filesys/free-map.c	2024-02-09 01:26:32.051953779 +0000
+++ pintos-solution/src/filesys/free-map.c	2024-04-30 04:42:51.000000000 +0000
@@ -8,6 +8,8 @@
 static struct file *free_map_file; /* Free map file. */
 static struct bitmap *free_map;    /* Free map, one bit per sector. */
 
+// P2 solution:
+
 /* Initializes the free map. */
 void free_map_init (void)
 {
@@ -73,3 +75,98 @@
   if (!bitmap_write (free_map, free_map_file))
     PANIC ("can't write free map");
 }
+
+
+// P4 tryout:
+// struct lock free_map_lock;
+
+// /* Initializes the free map. */
+// void free_map_init (void)
+// {
+//   free_map = bitmap_create (block_size (fs_device));
+//   if (free_map == NULL)
+//     PANIC ("bitmap creation failed--file system device is too large");
+//   bitmap_mark (free_map, FREE_MAP_SECTOR);
+//   bitmap_mark (free_map, ROOT_DIR_SECTOR);
+
+//   lock_init (&free_map_lock);
+// }
+
+// /* Allocates CNT consecutive sectors from the free map and stores
+//    the first into *SECTORP.
+//    Returns true if successful, false if not enough consecutive
+//    sectors were available or if the free_map file could not be
+//    written. */
+// bool free_map_allocate (size_t cnt, block_sector_t *sectorp)
+// {
+//   lock_acquire (&free_map_lock);
+//   block_sector_t sector = bitmap_scan_and_flip (free_map, 0, cnt, false);
+//   if (sector != BITMAP_ERROR && free_map_file != NULL &&
+//       !bitmap_write (free_map, free_map_file))
+//     {
+//       bitmap_set_multiple (free_map, sector, cnt, false);
+//       sector = BITMAP_ERROR;
+//     }
+//   lock_release (&free_map_lock);
+
+//   if (sector != BITMAP_ERROR)
+//     *sectorp = sector;
+  
+//   // Adjust free map file size after allocation
+//   // off_t new_size = bitmap_file_size(free_map);
+//   // if (new_size > inode_length(file_get_inode(free_map_file)))
+//   //   inode_extend(&file_get_inode(free_map_file)->data, new_size);
+
+//   return sector != BITMAP_ERROR;
+// }
+
+// // /* Makes CNT sectors starting at SECTOR available for use. */
+// void free_map_release (block_sector_t sector, size_t cnt)
+// {
+//   ASSERT (bitmap_all (free_map, sector, cnt));
+
+//   lock_acquire (&free_map_lock);
+//   bitmap_set_multiple (free_map, sector, cnt, false);
+//   bitmap_write (free_map, free_map_file);
+//   lock_release (&free_map_lock);
+// }
+
+// /* Opens the free map file and reads it from disk. */
+// void free_map_open (void)
+// {
+//   lock_acquire (&free_map_lock);
+//   free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
+//   lock_release (&free_map_lock);
+
+//   if (free_map_file == NULL)
+//     PANIC ("can't open free map");
+//   if (!bitmap_read (free_map, free_map_file))
+//     PANIC ("can't read free map");
+// }
+
+// /* Writes the free map to disk and closes the free map file. */
+// void free_map_close (void) {
+//   lock_acquire (&free_map_lock);
+//   file_close (free_map_file);
+//   lock_release (&free_map_lock);
+// }
+
+// /* Creates a new free map file on disk and writes the free map to
+//    it. */
+// void free_map_create (void)
+// {
+//   /* Create inode. */
+//   // if (!inode_create_2 (FREE_MAP_SECTOR, bitmap_file_size (free_map), false))
+//   if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map), false))
+//     PANIC ("free map creation failed");
+
+//   /* Write bitmap to file. */
+//   lock_acquire (&free_map_lock);
+//   free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
+//   lock_release (&free_map_lock);
+
+//   if (free_map_file == NULL)
+//     PANIC ("can't open free map");
+//   if (!bitmap_write (free_map, free_map_file))
+//     PANIC ("can't write free map");
+// }
diff -ruN aos_pintos/src/filesys/fsutil.c pintos-solution/src/filesys/fsutil.c
--- aos_pintos/src/filesys/fsutil.c	2024-02-09 01:26:32.039954307 +0000
+++ pintos-solution/src/filesys/fsutil.c	2024-04-30 04:44:01.000000000 +0000
@@ -217,3 +217,218 @@
   file_close (src);
   free (buffer);
 }
+
+// P4 tryout:
+
+
+// #include "userprog/syscall.h"
+// #include "filesys/filesys.h"
+// #include "filesys/directory.h"
+
+// /* List files in the root directory. */
+// void fsutil_ls (char **argv UNUSED)
+// {
+//   struct dir *dir;
+//   char name[NAME_MAX + 1];
+
+//   printf ("Files in the root directory:\n");
+//   dir = dir_open_root ();
+//   if (dir == NULL)
+//     PANIC ("root dir open failed");
+//   while (dir_readdir (dir, name))
+//     printf ("%s\n", name);
+//   dir_close (dir);
+//   printf ("End of listing.\n");
+// }
+
+// /* Prints the contents of file ARGV[1] to the system console as
+//    hex and ASCII. */
+// void fsutil_cat (char **argv)
+// {
+//   const char *file_name = argv[1];
+
+//   struct file *file;
+//   char *buffer;
+
+//   printf ("Printing '%s' to the console...\n", file_name);
+//   file = filesys_open (file_name);
+//   if (file == NULL)
+//     PANIC ("%s: open failed", file_name);
+//   buffer = palloc_get_page (PAL_ASSERT);
+//   for (;;)
+//     {
+//       off_t pos = file_tell (file);
+//       off_t n = file_read (file, buffer, PGSIZE);
+//       if (n == 0)
+//         break;
+
+//       hex_dump (pos, buffer, n, true);
+//     }
+//   palloc_free_page (buffer);
+//   file_close (file);
+// }
+
+// /* Deletes file ARGV[1]. */
+// void fsutil_rm (char **argv)
+// {
+//   const char *file_name = argv[1];
+
+//   printf ("Deleting '%s'...\n", file_name);
+//   if (!filesys_remove (file_name))
+//     PANIC ("%s: delete failed\n", file_name);
+// }
+
+// /* Extracts a ustar-format tar archive from the scratch block
+//    device into the Pintos file system. */
+// void fsutil_extract (char **argv UNUSED)
+// {
+//   static block_sector_t sector = 0;
+
+//   struct block *src;
+//   void *header, *data;
+
+//   /* Allocate buffers. */
+//   header = malloc (BLOCK_SECTOR_SIZE);
+//   data = malloc (BLOCK_SECTOR_SIZE);
+//   if (header == NULL || data == NULL)
+//     PANIC ("couldn't allocate buffers");
+
+//   /* Open source block device. */
+//   src = block_get_role (BLOCK_SCRATCH);
+//   if (src == NULL)
+//     PANIC ("couldn't open scratch device");
+
+//   printf ("Extracting ustar archive from scratch device "
+//           "into file system...\n");
+
+//   for (;;)
+//     {
+//       const char *file_name;
+//       const char *error;
+//       enum ustar_type type;
+//       int size;
+
+//       /* Read and parse ustar header. */
+//       block_read (src, sector++, header);
+//       error = ustar_parse_header (header, &file_name, &type, &size);
+//       if (error != NULL)
+//         PANIC ("bad ustar header in sector %" PRDSNu " (%s)", sector - 1,
+//                error);
+
+//       if (type == USTAR_EOF)
+//         {
+//           /* End of archive. */
+//           break;
+//         }
+//       else if (type == USTAR_DIRECTORY)
+//         printf ("ignoring directory %s\n", file_name);
+//       else if (type == USTAR_REGULAR)
+//         {
+//           struct file *dst;
+
+//           printf ("Putting '%s' into the file system...\n", file_name);
+
+//           /* Create destination file. */
+//           // if (!filesys_create (file_name, size))
+//           if (!filesys_create (file_name, size, false))
+//             PANIC ("%s: create failed", file_name);
+//           dst = filesys_open (file_name);
+//           if (dst == NULL)
+//             PANIC ("%s: open failed", file_name);
+
+//           /* Do copy. */
+//           while (size > 0)
+//             {
+//               int chunk_size =
+//                   (size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size);
+//               block_read (src, sector++, data);
+//               if (file_write (dst, data, chunk_size) != chunk_size)
+//                 PANIC ("%s: write failed with %d bytes unwritten", file_name,
+//                        size);
+//               size -= chunk_size;
+//             }
+
+//           /* Finish up. */
+//           file_close (dst);
+//         }
+//     }
+
+//   /* Erase the ustar header from the start of the block device,
+//      so that the extraction operation is idempotent.  We erase
+//      two blocks because two blocks of zeros are the ustar
+//      end-of-archive marker. */
+//   printf ("Erasing ustar archive...\n");
+//   memset (header, 0, BLOCK_SECTOR_SIZE);
+//   block_write (src, 0, header);
+//   block_write (src, 1, header);
+
+//   free (data);
+//   free (header);
+// }
+
+// /* Copies file FILE_NAME from the file system to the scratch
+//    device, in ustar format.
+
+//    The first call to this function will write starting at the
+//    beginning of the scratch device.  Later calls advance across
+//    the device.  This position is independent of that used for
+//    fsutil_extract(), so `extract' should precede all
+//    `append's. */
+// void fsutil_append (char **argv)
+// {
+//   static block_sector_t sector = 0;
+
+//   const char *file_name = argv[1];
+//   void *buffer;
+//   struct file *src;
+//   struct block *dst;
+//   off_t size;
+
+//   printf ("Appending '%s' to ustar archive on scratch device...\n", file_name);
+
+//   /* Allocate buffer. */
+//   buffer = malloc (BLOCK_SECTOR_SIZE);
+//   if (buffer == NULL)
+//     PANIC ("couldn't allocate buffer");
+
+//   /* Open source file. */
+//   src = filesys_open (file_name);
+//   if (src == NULL)
+//     PANIC ("%s: open failed", file_name);
+//   size = file_length (src);
+
+//   /* Open target block device. */
+//   dst = block_get_role (BLOCK_SCRATCH);
+//   if (dst == NULL)
+//     PANIC ("couldn't open scratch device");
+
+//   /* Write ustar header to first sector. */
+//   if (!ustar_make_header (file_name, USTAR_REGULAR, size, buffer))
+//     PANIC ("%s: name too long for ustar format", file_name);
+//   block_write (dst, sector++, buffer);
+
+//   /* Do copy. */
+//   while (size > 0)
+//     {
+//       int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
+//       if (sector >= block_size (dst))
+//         PANIC ("%s: out of space on scratch device", file_name);
+//       if (file_read (src, buffer, chunk_size) != chunk_size)
+//         PANIC ("%s: read failed with %" PROTd " bytes unread", file_name, size);
+//       memset ((uint8_t *) buffer + chunk_size, 0,
+//               BLOCK_SECTOR_SIZE - chunk_size);
+//       block_write (dst, sector++, buffer);
+//       size -= chunk_size;
+//     }
+
+//   /* Write ustar end-of-archive marker, which is two consecutive
+//      sectors full of zeros.  Don't advance our position past
+//      them, though, in case we have more files to append. */
+//   memset (buffer, 0, BLOCK_SECTOR_SIZE);
+//   block_write (dst, sector, buffer);
+//   block_write (dst, sector + 1, buffer);
+
+//   /* Finish up. */
+//   file_close (src);
+//   free (buffer);
+// }
diff -ruN aos_pintos/src/filesys/inode.c pintos-solution/src/filesys/inode.c
--- aos_pintos/src/filesys/inode.c	2024-02-09 01:26:32.067953074 +0000
+++ pintos-solution/src/filesys/inode.c	2024-04-30 04:40:00.000000000 +0000
@@ -10,6 +10,12 @@
 /* Identifies an inode. */
 #define INODE_MAGIC 0x494e4f44
 
+// P4 tryout:
+// #define DIRECT_BLOCKS 122
+// #define INDIRECT_BLOCKS 128
+// #define DOUBLY_INDIRECT_BLOCKS 128 * 128
+
+// P2 soltuion:
 /* On-disk inode.
    Must be exactly BLOCK_SECTOR_SIZE bytes long. */
 struct inode_disk
@@ -19,8 +25,18 @@
   unsigned magic;       /* Magic number. */
   bool is_symlink;      /* True if symbolic link, false otherwise. */
   uint32_t unused[124]; /* Not used. */
+
+// P4 tryout:
+//   block_sector_t direct_blocks[DIRECT_BLOCKS];  /* Direct block pointers. */
+//   block_sector_t indirect_block;      /* Indirect block pointer. */
+//   block_sector_t doubly_indirect_block; /* Doubly indirect block pointer. */
+//   bool is_dir;
 };
 
+// struct inode_indirect_block_sector {
+//   block_sector_t blocks[INDIRECT_BLOCKS];
+// };
+
 /* Returns the number of sectors to allocate for an inode SIZE
    bytes long. */
 static inline size_t bytes_to_sectors (off_t size)
@@ -337,3 +353,667 @@
   inode->data.is_symlink = is_symlink;
   block_write (fs_device, inode->sector, &inode->data);
 }
+
+
+
+// P4 tryout:
+
+// static block_sector_t
+// index_to_sector (const struct inode_disk *idisk, off_t index)
+// {
+//   off_t index_base = 0, index_limit = 0;   // base, limit for sector index
+//   block_sector_t ret;
+
+//   // (1) direct blocks
+//   index_limit += DIRECT_BLOCKS * 1;
+//   if (index < index_limit) {
+//     return idisk->direct_blocks[index];
+//   }
+//   index_base = index_limit;
+
+//   // (2) a single indirect block
+//   index_limit += 1 * INDIRECT_BLOCKS;
+//   if (index < index_limit) {
+//     struct inode_indirect_block_sector *indirect_idisk;
+//     indirect_idisk = calloc(1, sizeof(struct inode_indirect_block_sector));
+//     block_read (fs_device, idisk->indirect_block, indirect_idisk);
+
+//     ret = indirect_idisk->blocks[ index - index_base ];
+//     free(indirect_idisk);
+
+//     return ret;
+//   }
+//   index_base = index_limit;
+
+//   // (3) a single doubly indirect block
+//   index_limit += 1 * INDIRECT_BLOCKS * INDIRECT_BLOCKS;
+//   if (index < index_limit) {
+//     // first and second level block index, respecitvely
+//     off_t index_first =  (index - index_base) / INDIRECT_BLOCKS;
+//     off_t index_second = (index - index_base) % INDIRECT_BLOCKS;
+
+//     // fetch two indirect block sectors
+//     struct inode_indirect_block_sector *indirect_idisk;
+//     indirect_idisk = calloc(1, sizeof(struct inode_indirect_block_sector));
+
+//     block_read (fs_device, idisk->doubly_indirect_block, indirect_idisk);
+//     block_read (fs_device, indirect_idisk->blocks[index_first], indirect_idisk);
+//     ret = indirect_idisk->blocks[index_second];
+
+//     free(indirect_idisk);
+//     return ret;
+//   }
+
+//   // (4) what up?
+//   return -1;
+// }
+
+// block_sector_t byte_to_sector(const struct inode *inode, off_t pos)
+// {
+//   ASSERT(inode != NULL);
+//   if (0 <= pos && pos < inode->data.length) {
+//     // sector index
+//     off_t index = pos / BLOCK_SECTOR_SIZE;
+//     return index_to_sector (&inode->data, index);
+//   }
+//   else
+//     return -1;
+// }
+
+// /* List of open inodes, so that opening a single inode twice
+//    returns the same `struct inode'. */
+// static struct list open_inodes;
+// struct lock inode_lock;
+
+// /* Initializes the inode module. */
+// void inode_init (void) { list_init (&open_inodes); }
+
+// /* Initializes an inode with LENGTH bytes of data and
+//    writes the new inode to sector SECTOR on the file system
+//    device.
+//    Returns true if successful.
+//    Returns false if memory or disk allocation fails. */
+// bool inode_create (block_sector_t sector, off_t length, bool is_dir)
+// {
+//   struct inode_disk *disk_inode = NULL;
+//   bool success = false;
+
+//   ASSERT (length >= 0);
+
+//   /* If this assertion fails, the inode structure is not exactly
+//      one sector in size, and you should fix that. */
+//   ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);
+
+//   disk_inode = calloc (1, sizeof *disk_inode);
+//   if (disk_inode != NULL)
+//     {
+//       size_t sectors = bytes_to_sectors (length);
+//       disk_inode->length = length;
+//       disk_inode->magic = INODE_MAGIC;
+//       disk_inode->is_dir = is_dir;
+//       disk_inode->is_symlink = false;
+//       if (inode_allocate (disk_inode))
+//         {
+//           block_write (fs_device, sector, disk_inode);
+//           success = true;
+//         }
+//       free (disk_inode);
+//     }
+//   return success;
+// }
+
+// /* Reads an inode from SECTOR
+//    and returns a `struct inode' that contains it.
+//    Returns a null pointer if memory allocation fails. */
+// struct inode *inode_open (block_sector_t sector)
+// {
+//   struct list_elem *e;
+//   struct inode *inode;
+
+//   /* Check whether this inode is already open. */
+//   for (e = list_begin (&open_inodes); e != list_end (&open_inodes);
+//        e = list_next (e))
+//     {
+//       inode = list_entry (e, struct inode, elem);
+//       if (inode->sector == sector)
+//         {
+//           inode_reopen (inode);
+//           return inode;
+//         }
+//     }
+
+//   /* Allocate memory. */
+//   inode = malloc (sizeof *inode);
+//   if (inode == NULL)
+//     return NULL;
+
+//   /* Initialize. */
+//   list_push_front (&open_inodes, &inode->elem);
+//   inode->sector = sector;
+//   inode->open_cnt = 1;
+//   inode->deny_write_cnt = 0;
+//   inode->removed = false;
+//   block_read (fs_device, inode->sector, &inode->data);
+//   return inode;
+// }
+
+// /* Reopens and returns INODE. */
+// struct inode *inode_reopen (struct inode *inode)
+// {
+//   if (inode != NULL)
+//     inode->open_cnt++;
+//   return inode;
+// }
+
+// /* Returns INODE's inode number. */
+// block_sector_t inode_get_inumber (const struct inode *inode)
+// {
+//   return inode->sector;
+// }
+
+// /* Closes INODE and writes it to disk. (Does it?  Check code.)
+//    If this was the last reference to INODE, frees its memory.
+//    If INODE was also a removed inode, frees its blocks. */
+// void inode_close (struct inode *inode)
+// {
+//   /* Ignore null pointer. */
+//   if (inode == NULL)
+//     return;
+
+//   /* Release resources if this was the last opener. */
+//   if (--inode->open_cnt == 0)
+//     {
+//       /* Remove from inode list and release lock. */
+//       list_remove (&inode->elem);
+
+//       /* Deallocate blocks if removed. */
+//       if (inode->removed)
+//         {
+//           free_map_release (inode->sector, 1);
+//           inode_deallocate (inode);
+//         }
+
+//       free (inode);
+//     }
+// }
+
+
+// /* Marks INODE to be deleted when it is closed by the last caller who
+//    has it open. */
+// void inode_remove (struct inode *inode)
+// {
+//   ASSERT (inode != NULL);
+//   inode->removed = true;
+// }
+
+// /* Reads SIZE bytes from INODE into BUFFER, starting at position OFFSET.
+//    Returns the number of bytes actually read, which may be less
+//    than SIZE if an error occurs or end of file is reached. */
+// off_t inode_read_at (struct inode *inode, void *buffer_, off_t size,
+//                      off_t offset)
+// {
+//   uint8_t *buffer = buffer_;
+//   off_t bytes_read = 0;
+//   uint8_t *bounce = NULL;
+
+//   while (size > 0)
+//     {
+//       /* Disk sector to read, starting byte offset within sector. */
+//       block_sector_t sector_idx = byte_to_sector (inode, offset);
+//       int sector_ofs = offset % BLOCK_SECTOR_SIZE;
+
+//       /* Bytes left in inode, bytes left in sector, lesser of the two. */
+//       off_t inode_left = inode_length (inode) - offset;
+//       int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
+//       int min_left = inode_left < sector_left ? inode_left : sector_left;
+
+//       /* Number of bytes to actually copy out of this sector. */
+//       int chunk_size = size < min_left ? size : min_left;
+//       if (chunk_size <= 0)
+//         break;
+
+//       if (sector_idx == (block_sector_t)-1) {
+//         if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
+//           {
+//             /* Read full sector directly into caller's buffer. */
+//             block_read (fs_device, sector_idx, buffer + bytes_read);
+//           }
+//         else
+//           {
+//             /* Read sector into bounce buffer, then partially copy
+//               into caller's buffer. */
+//             if (bounce == NULL)
+//               {
+//                 bounce = malloc (BLOCK_SECTOR_SIZE);
+//                 if (bounce == NULL)
+//                   break;
+//               }
+//             block_read (fs_device, sector_idx, bounce);
+//             memcpy (buffer + bytes_read, bounce + sector_ofs, chunk_size);
+//           }
+//       } else {
+//         // Reading from unallocated block, fill buffer with zeros
+//         memset(buffer + bytes_read, 0, chunk_size);
+//       }
+
+//       /* Advance. */
+//       size -= chunk_size;
+//       offset += chunk_size;
+//       bytes_read += chunk_size;
+//     }
+//   free (bounce);
+
+//   return bytes_read;
+// }
+
+// /* Writes SIZE bytes from BUFFER into INODE, starting at OFFSET.
+//    Returns the number of bytes actually written, which may be
+//    less than SIZE if end of file is reached or an error occurs.
+//    (Normally a write at end of file would extend the inode, but
+//    growth is not yet implemented.) */
+// off_t inode_write_at (struct inode *inode, const void *buffer_, off_t size,
+//                       off_t offset)
+// {
+//   const uint8_t *buffer = buffer_;
+//   off_t bytes_written = 0;
+//   uint8_t *bounce = NULL;
+
+//   if (inode->deny_write_cnt)
+//     return 0;
+
+//   // beyond the EOF: extend the file
+//   if( byte_to_sector(inode, offset + size - 1) == -1u ) {
+//     // extend and reserve up to [offset + size] bytes
+//     bool success;
+//     success = inode_reserve (& inode->data, offset + size);
+//     if (!success) return 0;  // fail?
+
+//     // write back the (extended) file size
+//     inode->data.length = offset + size;
+//     block_write (fs_device, inode->sector, & inode->data);
+//   }
+
+//   while (size > 0)
+//     {
+//       /* Sector to write, starting byte offset within sector. */
+//       block_sector_t sector_idx = byte_to_sector (inode, offset);
+//       int sector_ofs = offset % BLOCK_SECTOR_SIZE;
+
+//       /* Bytes left in inode, bytes left in sector, lesser of the two. */
+//       off_t inode_left = inode_length (inode) - offset;
+//       int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
+//       int min_left = inode_left < sector_left ? inode_left : sector_left;
+
+//       /* Number of bytes to actually write into this sector. */
+//       int chunk_size = size < min_left ? size : min_left;
+//       if (chunk_size <= 0)
+//         break;
+
+//       if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
+//         {
+//           /* Write full sector directly to disk. */
+//           block_write (fs_device, sector_idx, buffer + bytes_written);
+//         }
+//       else
+//         {
+//           /* We need a bounce buffer. */
+//           if (bounce == NULL)
+//             {
+//               bounce = malloc (BLOCK_SECTOR_SIZE);
+//               if (bounce == NULL)
+//                 break;
+//             }
+
+//           /* If the sector contains data before or after the chunk
+//              we're writing, then we need to read in the sector
+//              first.  Otherwise we start with a sector of all zeros. */
+//           if (sector_ofs > 0 || chunk_size < sector_left)
+//             block_read (fs_device, sector_idx, bounce);
+//           else
+//             memset (bounce, 0, BLOCK_SECTOR_SIZE);
+//           memcpy (bounce + sector_ofs, buffer + bytes_written, chunk_size);
+//           block_write (fs_device, sector_idx, bounce);
+//         }
+
+//       /* Advance. */
+//       size -= chunk_size;
+//       offset += chunk_size;
+//       bytes_written += chunk_size;
+//     }
+//   free (bounce);
+
+//   return bytes_written;
+// }
+
+// /* Disables writes to INODE.
+//    May be called at most once per inode opener. */
+// void inode_deny_write (struct inode *inode)
+// {
+//   inode->deny_write_cnt++;
+//   ASSERT (inode->deny_write_cnt <= inode->open_cnt);
+// }
+
+// /* Re-enables writes to INODE.
+//    Must be called once by each inode opener who has called
+//    inode_deny_write() on the inode, before closing the inode. */
+// void inode_allow_write (struct inode *inode)
+// {
+//   ASSERT (inode->deny_write_cnt > 0);
+//   ASSERT (inode->deny_write_cnt <= inode->open_cnt);
+//   inode->deny_write_cnt--;
+// }
+
+// /* Returns the length, in bytes, of INODE's data. */
+// off_t inode_length (const struct inode *inode) { return inode->data.length; }
+
+// bool inode_get_symlink (struct inode *inode) { 
+//   ASSERT (inode != NULL);
+//   return inode->data.is_symlink; 
+// }
+
+// void inode_set_symlink (struct inode *inode, bool is_symlink)
+// {
+//   inode->data.is_symlink = is_symlink;
+//   block_write (fs_device, inode->sector, &inode->data);
+// }
+
+// bool inode_expand (struct inode_disk *disk_inode, off_t new_length)
+// {
+//   off_t old_length = disk_inode->length;
+//   off_t sectors_needed = bytes_to_sectors(new_length) - bytes_to_sectors(old_length);
+//   if (sectors_needed <= 0)
+//     return true; // No expansion needed
+
+//   size_t i;
+
+//   // Direct blocks
+//   for (i = 0; i < DIRECT_BLOCKS && sectors_needed > 0; ++i)
+//   {
+//     if (disk_inode->direct_blocks[i] == 0)
+//     {
+//       if (!free_map_allocate(1, &disk_inode->direct_blocks[i]))
+//         return false;
+//       --sectors_needed;
+//     }
+//   }
+
+//   // Indirect block
+//   if (sectors_needed > 0 && disk_inode->indirect_block == 0)
+//   {
+//     if (!free_map_allocate(1, &disk_inode->indirect_block))
+//       return false;
+//     --sectors_needed;
+//   }
+
+//   // Doubly indirect block
+//   if (sectors_needed > 0 && disk_inode->doubly_indirect_block == 0)
+//   {
+//     if (!free_map_allocate(1, &disk_inode->doubly_indirect_block))
+//       return false;
+//     --sectors_needed;
+//   }
+
+//   return sectors_needed <= 0;
+// }
+
+// off_t inode_extend (struct inode_disk *disk_inode, off_t new_length)
+// {
+//   if (new_length > disk_inode->length)
+//   {
+//     if (!inode_expand(disk_inode, new_length))
+//       return disk_inode->length;
+//     disk_inode->length = new_length;
+//   }
+//   return disk_inode->length;
+// }
+
+// bool inode_is_dir(const struct inode *inode)
+// {
+//     return inode != NULL && inode->data.is_dir;
+// }
+
+// /* Open an inode given its path. */
+// struct inode *inode_open_path(const char *path)
+// {
+//     struct inode *inode = NULL;
+//     struct dir *dir = NULL;
+//     char *path_copy = NULL;
+//     char *token, *save_ptr;
+
+//     /* Check if path is not null */
+//     if (path == NULL)
+//         return NULL;
+
+//     /* Make a copy of path for tokenizing */
+//     path_copy = malloc(strlen(path) + 1);
+//     if (path_copy == NULL)
+//         return NULL;
+//     strlcpy(path_copy, path, strlen(path) + 1);
+
+//     /* Tokenize the path to traverse directories */
+//     token = strtok_r(path_copy, "/", &save_ptr);
+//     if (token == NULL) {
+//         free(path_copy);
+//         return NULL; // Empty path
+//     }
+
+//     /* Open the root directory initially */
+//     dir = dir_open_root();
+//     if (dir == NULL) {
+//         free(path_copy);
+//         return NULL; // Failed to open root directory
+//     }
+
+//     /* Traverse through each token in the path */
+//     while (token != NULL && dir != NULL) {
+//         /* Lookup the entry corresponding to the token */
+//         if (!dir_lookup(dir, token, &inode)) {
+//             dir_close(dir);
+//             free(path_copy);
+//             return NULL; // Entry not found
+//         }
+
+//         /* Check if the inode is a directory */
+//         if (inode_is_dir(inode)) {
+//             /* Close the current directory and open the subdirectory */
+//             dir_close(dir);
+//             dir = dir_open(inode);
+//         } else {
+//             /* Not a directory, close the directory */
+//             dir_close(dir);
+//             dir = NULL;
+//         }
+
+//         /* Move to the next token */
+//         token = strtok_r(NULL, "/", &save_ptr);
+//     }
+
+//     free(path_copy);
+//     return inode;
+// }
+
+// /* Returns the physical length of the inode's data. */
+// off_t inode_length_physical(const struct inode *inode) {
+//     lock_acquire(&inode_lock);
+//     off_t length = inode->data.length;
+//     lock_release(&inode_lock);
+//     return length;
+// }
+
+// /* Returns the number of blocks allocated to the inode. */
+// blkcnt_t inode_get_blocks(const struct inode *inode) {
+//     lock_acquire(&inode_lock);
+//     off_t length = inode->data.length;
+//     blkcnt_t blocks = (length + BLOCK_SECTOR_SIZE - 1) / BLOCK_SECTOR_SIZE;
+//     lock_release(&inode_lock);
+//     return blocks;
+// }
+
+// /* Returns whether the file is removed or not. */
+// bool
+// inode_is_removed (const struct inode *inode)
+// {
+//   return inode->removed;
+// }
+
+// static inline size_t
+// min (size_t a, size_t b)
+// {
+//   return a < b ? a : b;
+// }
+
+// static
+// bool inode_allocate (struct inode_disk *disk_inode)
+// {
+//   return inode_reserve (disk_inode, disk_inode->length);
+// }
+
+// static bool
+// inode_reserve_indirect (block_sector_t* p_entry, size_t num_sectors, int level)
+// {
+//   static char zeros[BLOCK_SECTOR_SIZE];
+
+//   // only supports 2-level indirect block scheme as of now
+//   ASSERT (level <= 2);
+
+//   if (level == 0) {
+//     // base case : allocate a single sector if necessary and put it into the block
+//     if (*p_entry == 0) {
+//       if(! free_map_allocate (1, p_entry))
+//         return false;
+//       block_write (fs_device, *p_entry, zeros);
+//     }
+//     return true;
+//   }
+
+//   struct inode_indirect_block_sector indirect_block;
+//   if(*p_entry == 0) {
+//     // not yet allocated: allocate it, and fill with zero
+//     free_map_allocate (1, p_entry);
+//     block_write (fs_device,*p_entry, zeros);
+//   }
+//   block_read (fs_device, *p_entry, &indirect_block);
+
+//   size_t unit = (level == 1 ? 1 : INDIRECT_BLOCKS);
+//   size_t i, l = DIV_ROUND_UP (num_sectors, unit);
+
+//   for (i = 0; i < l; ++ i) {
+//     size_t subsize = min(num_sectors, unit);
+//     // inode_reserve_indirect (& indirect_block.blocks[i], subsize, level - 1);
+//     if(! inode_reserve_indirect (& indirect_block.blocks[i], subsize, level - 1))
+//       return false;
+//     num_sectors -= subsize;
+//   }
+
+//   ASSERT (num_sectors == 0);
+//   block_write (fs_device, *p_entry, &indirect_block);
+//   return true;
+// }
+
+// static bool
+// inode_reserve (struct inode_disk *disk_inode, off_t length)
+// {
+//   static char zeros[BLOCK_SECTOR_SIZE];
+
+//   if (length < 0) return false;
+
+//   // (remaining) number of sectors, occupied by this file.
+//   size_t num_sectors = bytes_to_sectors(length);
+//   size_t i, l;
+
+//   // (1) direct blocks
+//   l = min(num_sectors, DIRECT_BLOCKS * 1);
+//   for (i = 0; i < l; ++ i) {
+//     if (disk_inode->direct_blocks[i] == 0) { // unoccupied
+//       // free_map_allocate (1, &disk_inode->direct_blocks[i]);
+//       if(! free_map_allocate (1, &disk_inode->direct_blocks[i]))
+//         return false;
+//       block_write (fs_device, disk_inode->direct_blocks[i], zeros);
+//     }
+//   }
+//   num_sectors -= l;
+//   if(num_sectors == 0) return true;
+
+//   // (2) a single indirect block
+//   l = min(num_sectors, 1 * INDIRECT_BLOCKS);
+//   // inode_reserve_indirect (& disk_inode->indirect_block, l, 1);
+//   if(! inode_reserve_indirect (& disk_inode->indirect_block, l, 1))
+//     return false;
+//   num_sectors -= l;
+//   if(num_sectors == 0) return true;
+
+//   // (3) a single doubly indirect block
+//   l = min(num_sectors, 1 * INDIRECT_BLOCKS * INDIRECT_BLOCKS);
+//   // inode_reserve_indirect (& disk_inode->doubly_indirect_block, l, 2);
+//   if(! inode_reserve_indirect (& disk_inode->doubly_indirect_block, l, 2))
+//     return false;
+//   num_sectors -= l;
+//   if(num_sectors == 0) return true;
+
+//   ASSERT (num_sectors == 0);
+//   return false;
+// }
+
+// static void
+// inode_deallocate_indirect (block_sector_t entry, size_t num_sectors, int level)
+// {
+//   // only supports 2-level indirect block scheme as of now
+//   ASSERT (level <= 2);
+
+//   if (level == 0) {
+//     free_map_release (entry, 1);
+//     return;
+//   }
+
+//   struct inode_indirect_block_sector indirect_block;
+//   block_read (fs_device, entry, &indirect_block);
+
+//   size_t unit = (level == 1 ? 1 : INDIRECT_BLOCKS);
+//   size_t i, l = DIV_ROUND_UP (num_sectors, unit);
+
+//   for (i = 0; i < l; ++ i) {
+//     size_t subsize = min(num_sectors, unit);
+//     inode_deallocate_indirect (indirect_block.blocks[i], subsize, level - 1);
+//     num_sectors -= subsize;
+//   }
+
+//   ASSERT (num_sectors == 0);
+//   free_map_release (entry, 1);
+// }
+
+// static
+// bool inode_deallocate (struct inode *inode)
+// {
+//   off_t file_length = inode->data.length; // bytes
+//   if(file_length < 0) return false;
+
+//   // (remaining) number of sectors, occupied by this file.
+//   size_t num_sectors = bytes_to_sectors(file_length);
+//   size_t i, l;
+
+//   // (1) direct blocks
+//   l = min(num_sectors, DIRECT_BLOCKS * 1);
+//   for (i = 0; i < l; ++ i) {
+//     free_map_release (inode->data.direct_blocks[i], 1);
+//   }
+//   num_sectors -= l;
+
+//   // (2) a single indirect block
+//   l = min(num_sectors, 1 * INDIRECT_BLOCKS);
+//   if(l > 0) {
+//     inode_deallocate_indirect (inode->data.indirect_block, l, 1);
+//     num_sectors -= l;
+//   }
+
+//   // (3) a single doubly indirect block
+//   l = min(num_sectors, 1 * INDIRECT_BLOCKS * INDIRECT_BLOCKS);
+//   if(l > 0) {
+//     inode_deallocate_indirect (inode->data.doubly_indirect_block, l, 2);
+//     num_sectors -= l;
+//   }
+
+//   ASSERT (num_sectors == 0);
+//   return true;
+// }
+
+
diff -ruN aos_pintos/src/filesys/inode.h pintos-solution/src/filesys/inode.h
--- aos_pintos/src/filesys/inode.h	2024-02-09 01:26:32.047953955 +0000
+++ pintos-solution/src/filesys/inode.h	2024-04-30 04:38:41.000000000 +0000
@@ -22,4 +22,14 @@
 bool inode_get_symlink (struct inode *inode);
 void inode_set_symlink (struct inode *inode, bool is_symlink);
 
+// P4 tryout:
+// bool inode_expand (struct inode_disk *disk_inode, off_t new_length);
+// off_t inode_extend (struct inode_disk *disk_inode, off_t new_length);
+// block_sector_t byte_to_sector(const struct inode *inode, off_t pos);
+// bool inode_is_dir(const struct inode *inode);
+// struct inode *inode_open_path(const char *path);
+// off_t inode_length_physical(const struct inode *inode);
+// blkcnt_t inode_get_blocks(const struct inode *inode);
+// bool inode_is_removed (const struct inode *);
+
 #endif /* filesys/inode.h */
diff -ruN aos_pintos/src/lib/build/Makefile pintos-solution/src/lib/build/Makefile
--- aos_pintos/src/lib/build/Makefile	2024-02-09 02:53:22.256912855 +0000
+++ pintos-solution/src/lib/build/Makefile	1970-01-01 00:00:00.000000000 +0000
@@ -1,113 +0,0 @@
-# -*- makefile -*-
-
-# WARNING: Only edit me in the src/ directory!  (not in build/!)
-
-SRCDIR = ../..
-
-all: kernel.bin loader.bin
-
-include ../../Make.config
-include ../Make.vars
-include ../../tests/Make.tests
-
-# Compiler and assembler options.
-kernel.bin: CPPFLAGS += -I$(SRCDIR)/lib/kernel
-
-# Core kernel.
-threads_SRC  = threads/start.S		# Startup code.
-threads_SRC += threads/init.c		# Main program.
-threads_SRC += threads/thread.c		# Thread management core.
-threads_SRC += threads/switch.S		# Thread switch routine.
-threads_SRC += threads/interrupt.c	# Interrupt core.
-threads_SRC += threads/intr-stubs.S	# Interrupt stubs.
-threads_SRC += threads/synch.c		# Synchronization.
-threads_SRC += threads/palloc.c		# Page allocator.
-threads_SRC += threads/malloc.c		# Subpage allocator.
-
-# Device driver code.
-devices_SRC  = devices/pit.c		# Programmable interrupt timer chip.
-devices_SRC += devices/timer.c		# Periodic timer device.
-devices_SRC += devices/kbd.c		# Keyboard device.
-devices_SRC += devices/vga.c		# Video device.
-devices_SRC += devices/serial.c		# Serial port device.
-devices_SRC += devices/block.c		# Block device abstraction layer.
-devices_SRC += devices/partition.c	# Partition block device.
-devices_SRC += devices/ide.c		# IDE disk block device.
-devices_SRC += devices/input.c		# Serial and keyboard input.
-devices_SRC += devices/intq.c		# Interrupt queue.
-devices_SRC += devices/rtc.c		# Real-time clock.
-devices_SRC += devices/shutdown.c	# Reboot and power off.
-devices_SRC += devices/speaker.c	# PC speaker.
-
-# Library code shared between kernel and user programs.
-lib_SRC  = lib/debug.c			# Debug helpers.
-lib_SRC += lib/random.c			# Pseudo-random numbers.
-lib_SRC += lib/stdio.c			# I/O library.
-lib_SRC += lib/stdlib.c			# Utility functions.
-lib_SRC += lib/string.c			# String functions.
-lib_SRC += lib/arithmetic.c		# 64-bit arithmetic for GCC.
-lib_SRC += lib/ustar.c			# Unix standard tar format utilities.
-
-# Kernel-specific library code.
-lib/kernel_SRC  = lib/kernel/debug.c	# Debug helpers.
-lib/kernel_SRC += lib/kernel/list.c	# Doubly-linked lists.
-lib/kernel_SRC += lib/kernel/bitmap.c	# Bitmaps.
-lib/kernel_SRC += lib/kernel/hash.c	# Hash tables.
-lib/kernel_SRC += lib/kernel/console.c	# printf(), putchar().
-
-# User process code.
-userprog_SRC  = userprog/process.c	# Process loading.
-userprog_SRC += userprog/pagedir.c	# Page directories.
-userprog_SRC += userprog/exception.c	# User exception handler.
-userprog_SRC += userprog/syscall.c	# System call handler.
-userprog_SRC += userprog/gdt.c		# GDT initialization.
-userprog_SRC += userprog/tss.c		# TSS management.
-
-# No virtual memory code yet.
-vm_SRC = vm/frame.c			# Some file.
-vm_SRC += vm/page.c			# Some file.
-vm_SRC += vm/swap.c			# Some file.
-
-# Filesystem code.
-filesys_SRC  = filesys/filesys.c	# Filesystem core.
-filesys_SRC += filesys/free-map.c	# Free sector bitmap.
-filesys_SRC += filesys/file.c		# Files.
-filesys_SRC += filesys/directory.c	# Directories.
-filesys_SRC += filesys/inode.c		# File headers.
-filesys_SRC += filesys/fsutil.c		# Utilities.
-
-SOURCES = $(foreach dir,$(KERNEL_SUBDIRS),$($(dir)_SRC))
-OBJECTS = $(patsubst %.c,%.o,$(patsubst %.S,%.o,$(SOURCES)))
-DEPENDS = $(patsubst %.o,%.d,$(OBJECTS))
-
-threads/kernel.lds.s: CPPFLAGS += -P
-threads/kernel.lds.s: threads/kernel.lds.S threads/loader.h
-
-kernel.o: threads/kernel.lds.s $(OBJECTS) 
-	$(LD) -T $< -o $@ $(OBJECTS)
-
-kernel.bin: kernel.o
-	$(OBJCOPY) -R .note -R .comment -S $< $@
-
-threads/loader.o: threads/loader.S
-	$(CC) -c $< -o $@ $(ASFLAGS) $(CPPFLAGS) $(DEFINES)
-
-loader.bin: threads/loader.o
-	$(LD) -N -e 0 -Ttext 0x7c00 --oformat binary -o $@ $<
-
-os.dsk: kernel.bin
-	cat $^ > $@
-
-clean::
-	rm -f $(OBJECTS) $(DEPENDS) 
-	rm -f threads/loader.o threads/kernel.lds.s threads/loader.d
-	rm -f kernel.bin.tmp
-	rm -f kernel.o kernel.lds.s
-	rm -f kernel.bin loader.bin
-	rm -f bochsout.txt bochsrc.txt
-	rm -f results grade
-
-Makefile: $(SRCDIR)/Makefile.build
-	cp $< $@
-
--include $(DEPENDS)
diff -ruN aos_pintos/src/lib/build/devices/block.d pintos-solution/src/lib/build/devices/block.d
--- aos_pintos/src/lib/build/devices/block.d	2024-02-09 02:53:23.148882564 +0000
+++ pintos-solution/src/lib/build/devices/block.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-devices/block.o: ../../devices/block.c ../../devices/block.h \
- ../../lib/stddef.h ../../lib/inttypes.h ../../lib/stdint.h \
- ../../lib/kernel/list.h ../../lib/stdbool.h ../../lib/string.h \
- ../../lib/stdio.h ../../lib/debug.h ../../lib/stdarg.h \
- ../../lib/kernel/stdio.h ../../devices/ide.h ../../threads/malloc.h
Binary files aos_pintos/src/lib/build/devices/block.o and pintos-solution/src/lib/build/devices/block.o differ
diff -ruN aos_pintos/src/lib/build/devices/ide.d pintos-solution/src/lib/build/devices/ide.d
--- aos_pintos/src/lib/build/devices/ide.d	2024-02-09 02:53:23.284877946 +0000
+++ pintos-solution/src/lib/build/devices/ide.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-devices/ide.o: ../../devices/ide.c ../../devices/ide.h ../../lib/ctype.h \
- ../../lib/debug.h ../../lib/stdbool.h ../../lib/stdio.h \
- ../../lib/stdarg.h ../../lib/stddef.h ../../lib/stdint.h \
- ../../lib/kernel/stdio.h ../../devices/block.h ../../lib/inttypes.h \
- ../../devices/partition.h ../../devices/timer.h ../../lib/round.h \
- ../../threads/io.h ../../threads/interrupt.h ../../threads/synch.h \
- ../../lib/kernel/list.h
Binary files aos_pintos/src/lib/build/devices/ide.o and pintos-solution/src/lib/build/devices/ide.o differ
diff -ruN aos_pintos/src/lib/build/devices/input.d pintos-solution/src/lib/build/devices/input.d
--- aos_pintos/src/lib/build/devices/input.d	2024-02-09 02:53:23.316876859 +0000
+++ pintos-solution/src/lib/build/devices/input.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-devices/input.o: ../../devices/input.c ../../devices/input.h \
- ../../lib/stdbool.h ../../lib/stdint.h ../../lib/debug.h \
- ../../devices/intq.h ../../threads/interrupt.h ../../threads/synch.h \
- ../../lib/kernel/list.h ../../lib/stddef.h ../../devices/serial.h
Binary files aos_pintos/src/lib/build/devices/input.o and pintos-solution/src/lib/build/devices/input.o differ
diff -ruN aos_pintos/src/lib/build/devices/intq.d pintos-solution/src/lib/build/devices/intq.d
--- aos_pintos/src/lib/build/devices/intq.d	2024-02-09 02:53:23.380874686 +0000
+++ pintos-solution/src/lib/build/devices/intq.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-devices/intq.o: ../../devices/intq.c ../../devices/intq.h \
- ../../threads/interrupt.h ../../lib/stdbool.h ../../lib/stdint.h \
- ../../threads/synch.h ../../lib/kernel/list.h ../../lib/stddef.h \
- ../../lib/debug.h ../../threads/thread.h
Binary files aos_pintos/src/lib/build/devices/intq.o and pintos-solution/src/lib/build/devices/intq.o differ
diff -ruN aos_pintos/src/lib/build/devices/kbd.d pintos-solution/src/lib/build/devices/kbd.d
--- aos_pintos/src/lib/build/devices/kbd.d	2024-02-09 02:53:22.992887862 +0000
+++ pintos-solution/src/lib/build/devices/kbd.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-devices/kbd.o: ../../devices/kbd.c ../../devices/kbd.h ../../lib/stdint.h \
- ../../lib/ctype.h ../../lib/debug.h ../../lib/stdio.h ../../lib/stdarg.h \
- ../../lib/stdbool.h ../../lib/stddef.h ../../lib/kernel/stdio.h \
- ../../lib/string.h ../../devices/input.h ../../devices/shutdown.h \
- ../../threads/interrupt.h ../../threads/io.h
Binary files aos_pintos/src/lib/build/devices/kbd.o and pintos-solution/src/lib/build/devices/kbd.o differ
diff -ruN aos_pintos/src/lib/build/devices/partition.d pintos-solution/src/lib/build/devices/partition.d
--- aos_pintos/src/lib/build/devices/partition.d	2024-02-09 02:53:23.196880934 +0000
+++ pintos-solution/src/lib/build/devices/partition.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-devices/partition.o: ../../devices/partition.c ../../devices/partition.h \
- ../../lib/packed.h ../../lib/stdlib.h ../../lib/stddef.h \
- ../../lib/string.h ../../lib/stdio.h ../../lib/debug.h \
- ../../lib/stdarg.h ../../lib/stdbool.h ../../lib/stdint.h \
- ../../lib/kernel/stdio.h ../../devices/block.h ../../lib/inttypes.h \
- ../../threads/malloc.h
Binary files aos_pintos/src/lib/build/devices/partition.o and pintos-solution/src/lib/build/devices/partition.o differ
diff -ruN aos_pintos/src/lib/build/devices/pit.d pintos-solution/src/lib/build/devices/pit.d
--- aos_pintos/src/lib/build/devices/pit.d	2024-02-09 02:53:22.880891664 +0000
+++ pintos-solution/src/lib/build/devices/pit.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,3 +0,0 @@
-devices/pit.o: ../../devices/pit.c ../../devices/pit.h ../../lib/stdint.h \
- ../../lib/debug.h ../../threads/interrupt.h ../../lib/stdbool.h \
- ../../threads/io.h ../../lib/stddef.h
Binary files aos_pintos/src/lib/build/devices/pit.o and pintos-solution/src/lib/build/devices/pit.o differ
diff -ruN aos_pintos/src/lib/build/devices/rtc.d pintos-solution/src/lib/build/devices/rtc.d
--- aos_pintos/src/lib/build/devices/rtc.d	2024-02-09 02:53:23.420873328 +0000
+++ pintos-solution/src/lib/build/devices/rtc.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-devices/rtc.o: ../../devices/rtc.c ../../devices/rtc.h ../../lib/round.h \
- ../../lib/stdio.h ../../lib/debug.h ../../lib/stdarg.h \
- ../../lib/stdbool.h ../../lib/stddef.h ../../lib/stdint.h \
- ../../lib/kernel/stdio.h ../../threads/io.h
Binary files aos_pintos/src/lib/build/devices/rtc.o and pintos-solution/src/lib/build/devices/rtc.o differ
diff -ruN aos_pintos/src/lib/build/devices/serial.d pintos-solution/src/lib/build/devices/serial.d
--- aos_pintos/src/lib/build/devices/serial.d	2024-02-09 02:53:23.092884466 +0000
+++ pintos-solution/src/lib/build/devices/serial.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-devices/serial.o: ../../devices/serial.c ../../devices/serial.h \
- ../../lib/stdint.h ../../lib/debug.h ../../devices/input.h \
- ../../lib/stdbool.h ../../devices/intq.h ../../threads/interrupt.h \
- ../../threads/synch.h ../../lib/kernel/list.h ../../lib/stddef.h \
- ../../devices/timer.h ../../lib/round.h ../../threads/io.h \
- ../../threads/thread.h
Binary files aos_pintos/src/lib/build/devices/serial.o and pintos-solution/src/lib/build/devices/serial.o differ
diff -ruN aos_pintos/src/lib/build/devices/shutdown.d pintos-solution/src/lib/build/devices/shutdown.d
--- aos_pintos/src/lib/build/devices/shutdown.d	2024-02-09 02:53:23.464871833 +0000
+++ pintos-solution/src/lib/build/devices/shutdown.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-devices/shutdown.o: ../../devices/shutdown.c ../../devices/shutdown.h \
- ../../lib/debug.h ../../lib/kernel/console.h ../../lib/stdio.h \
- ../../lib/stdarg.h ../../lib/stdbool.h ../../lib/stddef.h \
- ../../lib/stdint.h ../../lib/kernel/stdio.h ../../devices/kbd.h \
- ../../devices/serial.h ../../devices/timer.h ../../lib/round.h \
- ../../threads/io.h ../../threads/thread.h ../../lib/kernel/list.h
Binary files aos_pintos/src/lib/build/devices/shutdown.o and pintos-solution/src/lib/build/devices/shutdown.o differ
diff -ruN aos_pintos/src/lib/build/devices/speaker.d pintos-solution/src/lib/build/devices/speaker.d
--- aos_pintos/src/lib/build/devices/speaker.d	2024-02-09 02:53:23.496870747 +0000
+++ pintos-solution/src/lib/build/devices/speaker.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-devices/speaker.o: ../../devices/speaker.c ../../devices/speaker.h \
- ../../devices/pit.h ../../lib/stdint.h ../../threads/io.h \
- ../../lib/stddef.h ../../threads/interrupt.h ../../lib/stdbool.h \
- ../../devices/timer.h ../../lib/round.h
Binary files aos_pintos/src/lib/build/devices/speaker.o and pintos-solution/src/lib/build/devices/speaker.o differ
diff -ruN aos_pintos/src/lib/build/devices/timer.d pintos-solution/src/lib/build/devices/timer.d
--- aos_pintos/src/lib/build/devices/timer.d	2024-02-09 02:53:22.944889491 +0000
+++ pintos-solution/src/lib/build/devices/timer.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-devices/timer.o: ../../devices/timer.c ../../devices/timer.h \
- ../../lib/round.h ../../lib/stdint.h ../../lib/debug.h \
- ../../lib/inttypes.h ../../lib/stdio.h ../../lib/stdarg.h \
- ../../lib/stdbool.h ../../lib/stddef.h ../../lib/kernel/stdio.h \
- ../../devices/pit.h ../../threads/interrupt.h ../../threads/synch.h \
- ../../lib/kernel/list.h ../../threads/thread.h
Binary files aos_pintos/src/lib/build/devices/timer.o and pintos-solution/src/lib/build/devices/timer.o differ
diff -ruN aos_pintos/src/lib/build/devices/vga.d pintos-solution/src/lib/build/devices/vga.d
--- aos_pintos/src/lib/build/devices/vga.d	2024-02-09 02:53:23.044886095 +0000
+++ pintos-solution/src/lib/build/devices/vga.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-devices/vga.o: ../../devices/vga.c ../../devices/vga.h ../../lib/round.h \
- ../../lib/stdint.h ../../lib/stddef.h ../../lib/string.h \
- ../../devices/speaker.h ../../threads/io.h ../../threads/interrupt.h \
- ../../lib/stdbool.h ../../threads/vaddr.h ../../lib/debug.h \
- ../../threads/loader.h
Binary files aos_pintos/src/lib/build/devices/vga.o and pintos-solution/src/lib/build/devices/vga.o differ
Binary files aos_pintos/src/lib/build/kernel.bin and pintos-solution/src/lib/build/kernel.bin differ
Binary files aos_pintos/src/lib/build/kernel.o and pintos-solution/src/lib/build/kernel.o differ
diff -ruN aos_pintos/src/lib/build/lib/arithmetic.d pintos-solution/src/lib/build/lib/arithmetic.d
--- aos_pintos/src/lib/build/lib/arithmetic.d	2024-02-09 02:53:23.864858251 +0000
+++ pintos-solution/src/lib/build/lib/arithmetic.d	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-lib/arithmetic.o: ../../lib/arithmetic.c ../../lib/stdint.h
Binary files aos_pintos/src/lib/build/lib/arithmetic.o and pintos-solution/src/lib/build/lib/arithmetic.o differ
diff -ruN aos_pintos/src/lib/build/lib/debug.d pintos-solution/src/lib/build/lib/debug.d
--- aos_pintos/src/lib/build/lib/debug.d	2024-02-09 02:53:23.524869796 +0000
+++ pintos-solution/src/lib/build/lib/debug.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,3 +0,0 @@
-lib/debug.o: ../../lib/debug.c ../../lib/debug.h ../../lib/stdarg.h \
- ../../lib/stdbool.h ../../lib/stddef.h ../../lib/stdio.h \
- ../../lib/stdint.h ../../lib/kernel/stdio.h ../../lib/string.h
Binary files aos_pintos/src/lib/build/lib/debug.o and pintos-solution/src/lib/build/lib/debug.o differ
diff -ruN aos_pintos/src/lib/build/lib/kernel/bitmap.d pintos-solution/src/lib/build/lib/kernel/bitmap.d
--- aos_pintos/src/lib/build/lib/kernel/bitmap.d	2024-02-09 02:53:24.152848471 +0000
+++ pintos-solution/src/lib/build/lib/kernel/bitmap.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-lib/kernel/bitmap.o: ../../lib/kernel/bitmap.c ../../lib/kernel/bitmap.h \
- ../../lib/stdbool.h ../../lib/stddef.h ../../lib/inttypes.h \
- ../../lib/stdint.h ../../lib/debug.h ../../lib/limits.h \
- ../../lib/round.h ../../lib/stdio.h ../../lib/stdarg.h \
- ../../lib/kernel/stdio.h ../../threads/malloc.h
Binary files aos_pintos/src/lib/build/lib/kernel/bitmap.o and pintos-solution/src/lib/build/lib/kernel/bitmap.o differ
diff -ruN aos_pintos/src/lib/build/lib/kernel/console.d pintos-solution/src/lib/build/lib/kernel/console.d
--- aos_pintos/src/lib/build/lib/kernel/console.d	2024-02-09 02:53:24.288843853 +0000
+++ pintos-solution/src/lib/build/lib/kernel/console.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-lib/kernel/console.o: ../../lib/kernel/console.c \
- ../../lib/kernel/console.h ../../lib/stdarg.h ../../lib/stdio.h \
- ../../lib/debug.h ../../lib/stdbool.h ../../lib/stddef.h \
- ../../lib/stdint.h ../../lib/kernel/stdio.h ../../devices/serial.h \
- ../../devices/vga.h ../../threads/init.h ../../threads/interrupt.h \
- ../../threads/synch.h ../../lib/kernel/list.h
Binary files aos_pintos/src/lib/build/lib/kernel/console.o and pintos-solution/src/lib/build/lib/kernel/console.o differ
diff -ruN aos_pintos/src/lib/build/lib/kernel/debug.d pintos-solution/src/lib/build/lib/kernel/debug.d
--- aos_pintos/src/lib/build/lib/kernel/debug.d	2024-02-09 02:53:23.956855126 +0000
+++ pintos-solution/src/lib/build/lib/kernel/debug.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-lib/kernel/debug.o: ../../lib/kernel/debug.c ../../lib/debug.h \
- ../../lib/kernel/console.h ../../lib/stdarg.h ../../lib/stdbool.h \
- ../../lib/stddef.h ../../lib/stdio.h ../../lib/stdint.h \
- ../../lib/kernel/stdio.h ../../lib/string.h ../../threads/init.h \
- ../../threads/interrupt.h ../../threads/thread.h ../../lib/kernel/list.h \
- ../../threads/switch.h ../../threads/vaddr.h ../../threads/loader.h \
- ../../devices/serial.h ../../devices/shutdown.h
Binary files aos_pintos/src/lib/build/lib/kernel/debug.o and pintos-solution/src/lib/build/lib/kernel/debug.o differ
diff -ruN aos_pintos/src/lib/build/lib/kernel/hash.d pintos-solution/src/lib/build/lib/kernel/hash.d
--- aos_pintos/src/lib/build/lib/kernel/hash.d	2024-02-09 02:53:24.240845483 +0000
+++ pintos-solution/src/lib/build/lib/kernel/hash.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-lib/kernel/hash.o: ../../lib/kernel/hash.c ../../lib/kernel/hash.h \
- ../../lib/stdbool.h ../../lib/stddef.h ../../lib/stdint.h \
- ../../lib/kernel/list.h ../../lib/kernel/../debug.h \
- ../../threads/malloc.h ../../lib/debug.h
Binary files aos_pintos/src/lib/build/lib/kernel/hash.o and pintos-solution/src/lib/build/lib/kernel/hash.o differ
diff -ruN aos_pintos/src/lib/build/lib/kernel/list.d pintos-solution/src/lib/build/lib/kernel/list.d
--- aos_pintos/src/lib/build/lib/kernel/list.d	2024-02-09 02:53:24.064851459 +0000
+++ pintos-solution/src/lib/build/lib/kernel/list.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-lib/kernel/list.o: ../../lib/kernel/list.c ../../lib/kernel/list.h \
- ../../lib/stdbool.h ../../lib/stddef.h ../../lib/stdint.h \
- ../../lib/kernel/../debug.h ../../threads/thread.h ../../lib/debug.h \
- ../../lib/kernel/list.h
Binary files aos_pintos/src/lib/build/lib/kernel/list.o and pintos-solution/src/lib/build/lib/kernel/list.o differ
diff -ruN aos_pintos/src/lib/build/lib/random.d pintos-solution/src/lib/build/lib/random.d
--- aos_pintos/src/lib/build/lib/random.d	2024-02-09 02:53:23.576868031 +0000
+++ pintos-solution/src/lib/build/lib/random.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,2 +0,0 @@
-lib/random.o: ../../lib/random.c ../../lib/random.h ../../lib/stddef.h \
- ../../lib/stdbool.h ../../lib/stdint.h ../../lib/debug.h
Binary files aos_pintos/src/lib/build/lib/random.o and pintos-solution/src/lib/build/lib/random.o differ
diff -ruN aos_pintos/src/lib/build/lib/stdio.d pintos-solution/src/lib/build/lib/stdio.d
--- aos_pintos/src/lib/build/lib/stdio.d	2024-02-09 02:53:23.680864499 +0000
+++ pintos-solution/src/lib/build/lib/stdio.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-lib/stdio.o: ../../lib/stdio.c ../../lib/stdio.h ../../lib/debug.h \
- ../../lib/stdarg.h ../../lib/stdbool.h ../../lib/stddef.h \
- ../../lib/stdint.h ../../lib/kernel/stdio.h ../../lib/ctype.h \
- ../../lib/inttypes.h ../../lib/round.h ../../lib/string.h
Binary files aos_pintos/src/lib/build/lib/stdio.o and pintos-solution/src/lib/build/lib/stdio.o differ
diff -ruN aos_pintos/src/lib/build/lib/stdlib.d pintos-solution/src/lib/build/lib/stdlib.d
--- aos_pintos/src/lib/build/lib/stdlib.d	2024-02-09 02:53:23.740862462 +0000
+++ pintos-solution/src/lib/build/lib/stdlib.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,3 +0,0 @@
-lib/stdlib.o: ../../lib/stdlib.c ../../lib/ctype.h ../../lib/debug.h \
- ../../lib/random.h ../../lib/stddef.h ../../lib/stdlib.h \
- ../../lib/stdbool.h
Binary files aos_pintos/src/lib/build/lib/stdlib.o and pintos-solution/src/lib/build/lib/stdlib.o differ
diff -ruN aos_pintos/src/lib/build/lib/string.d pintos-solution/src/lib/build/lib/string.d
--- aos_pintos/src/lib/build/lib/string.d	2024-02-09 02:53:23.820859744 +0000
+++ pintos-solution/src/lib/build/lib/string.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,2 +0,0 @@
-lib/string.o: ../../lib/string.c ../../lib/string.h ../../lib/stddef.h \
- ../../lib/debug.h
Binary files aos_pintos/src/lib/build/lib/string.o and pintos-solution/src/lib/build/lib/string.o differ
diff -ruN aos_pintos/src/lib/build/lib/ustar.d pintos-solution/src/lib/build/lib/ustar.d
--- aos_pintos/src/lib/build/lib/ustar.d	2024-02-09 02:53:23.916856485 +0000
+++ pintos-solution/src/lib/build/lib/ustar.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-lib/ustar.o: ../../lib/ustar.c ../../lib/ustar.h ../../lib/stdbool.h \
- ../../lib/limits.h ../../lib/packed.h ../../lib/stdio.h \
- ../../lib/debug.h ../../lib/stdarg.h ../../lib/stddef.h \
- ../../lib/stdint.h ../../lib/kernel/stdio.h ../../lib/string.h
Binary files aos_pintos/src/lib/build/lib/ustar.o and pintos-solution/src/lib/build/lib/ustar.o differ
Binary files aos_pintos/src/lib/build/loader.bin and pintos-solution/src/lib/build/loader.bin differ
diff -ruN aos_pintos/src/lib/build/results pintos-solution/src/lib/build/results
--- aos_pintos/src/lib/build/results	2024-02-09 02:53:33.144543112 +0000
+++ pintos-solution/src/lib/build/results	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-pass tests/lib/sorted-thread-list
-pass tests/lib/unsorted-thread-list
-pass tests/lib/bad-input
-pass tests/lib/not-found
diff -ruN aos_pintos/src/lib/build/tests/lib/bad-input.output pintos-solution/src/lib/build/tests/lib/bad-input.output
--- aos_pintos/src/lib/build/tests/lib/bad-input.output	2024-02-09 02:53:32.532563896 +0000
+++ pintos-solution/src/lib/build/tests/lib/bad-input.output	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-qemu-system-i386 -device isa-debug-exit -drive file=/tmp/A7D2wtSd8h.dsk,format=raw,index=0,media=disk -m 4 -net none -nographic -monitor null
-PiLo hda1
-Loading.........
-Kernel command line: -q run bad-input
-Pintos booting with 3,968 kB RAM...
-367 pages available in kernel pool.
-367 pages available in user pool.
-Calibrating timer...  445,644,800 loops/s.
-Boot complete.
-Executing 'bad-input':
-(bad-input) begin
-(bad-input) sorted index -1
-(bad-input) end
-Execution of 'bad-input' complete.
-Timer: 31 ticks
-Thread: 0 idle ticks, 31 kernel ticks, 0 user ticks
-Console: 390 characters output
-Keyboard: 0 keys pressed
-Powering off...
diff -ruN aos_pintos/src/lib/build/tests/lib/bad-input.result pintos-solution/src/lib/build/tests/lib/bad-input.result
--- aos_pintos/src/lib/build/tests/lib/bad-input.result	2024-02-09 02:53:32.580562266 +0000
+++ pintos-solution/src/lib/build/tests/lib/bad-input.result	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-PASS
diff -ruN aos_pintos/src/lib/build/tests/lib/listfunctests.d pintos-solution/src/lib/build/tests/lib/listfunctests.d
--- aos_pintos/src/lib/build/tests/lib/listfunctests.d	2024-02-09 02:53:24.332842359 +0000
+++ pintos-solution/src/lib/build/tests/lib/listfunctests.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-tests/lib/listfunctests.o: ../../tests/lib/listfunctests.c \
- ../../tests/lib/tests.h ../../threads/thread.h ../../lib/debug.h \
- ../../lib/kernel/list.h ../../lib/stdbool.h ../../lib/stddef.h \
- ../../lib/stdint.h ../../threads/malloc.h ../../lib/kernel/list.h \
- ../../lib/string.h ../../lib/stdio.h ../../lib/stdarg.h \
- ../../lib/kernel/stdio.h
Binary files aos_pintos/src/lib/build/tests/lib/listfunctests.o and pintos-solution/src/lib/build/tests/lib/listfunctests.o differ
diff -ruN aos_pintos/src/lib/build/tests/lib/not-found.output pintos-solution/src/lib/build/tests/lib/not-found.output
--- aos_pintos/src/lib/build/tests/lib/not-found.output	2024-02-09 02:53:33.080545285 +0000
+++ pintos-solution/src/lib/build/tests/lib/not-found.output	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-qemu-system-i386 -device isa-debug-exit -drive file=/tmp/2TQO6ayBMX.dsk,format=raw,index=0,media=disk -m 4 -net none -nographic -monitor null
-PiLo hda1
-Loading.........
-Kernel command line: -q run not-found
-Pintos booting with 3,968 kB RAM...
-367 pages available in kernel pool.
-367 pages available in user pool.
-Calibrating timer...  421,068,800 loops/s.
-Boot complete.
-Executing 'not-found':
-(not-found) begin
-(not-found) sorted index -1
-(not-found) end
-Execution of 'not-found' complete.
-Timer: 32 ticks
-Thread: 0 idle ticks, 32 kernel ticks, 0 user ticks
-Console: 390 characters output
-Keyboard: 0 keys pressed
-Powering off...
diff -ruN aos_pintos/src/lib/build/tests/lib/not-found.result pintos-solution/src/lib/build/tests/lib/not-found.result
--- aos_pintos/src/lib/build/tests/lib/not-found.result	2024-02-09 02:53:33.136543384 +0000
+++ pintos-solution/src/lib/build/tests/lib/not-found.result	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-PASS
diff -ruN aos_pintos/src/lib/build/tests/lib/sorted-thread-list.output pintos-solution/src/lib/build/tests/lib/sorted-thread-list.output
--- aos_pintos/src/lib/build/tests/lib/sorted-thread-list.output	2024-02-09 02:53:31.444600844 +0000
+++ pintos-solution/src/lib/build/tests/lib/sorted-thread-list.output	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-qemu-system-i386 -device isa-debug-exit -drive file=/tmp/wvcA6Reo2W.dsk,format=raw,index=0,media=disk -m 4 -net none -nographic -monitor null
-PiLo hda1
-Loading.........
-Kernel command line: -q run sorted-thread-list
-Pintos booting with 3,968 kB RAM...
-367 pages available in kernel pool.
-367 pages available in user pool.
-Calibrating timer...  209,510,400 loops/s.
-Boot complete.
-Executing 'sorted-thread-list':
-(sorted-thread-list) begin
-(sorted-thread-list) sorted index 4
-(sorted-thread-list) end
-Execution of 'sorted-thread-list' complete.
-Timer: 21 ticks
-Thread: 0 idle ticks, 21 kernel ticks, 0 user ticks
-Console: 443 characters output
-Keyboard: 0 keys pressed
-Powering off...
diff -ruN aos_pintos/src/lib/build/tests/lib/sorted-thread-list.result pintos-solution/src/lib/build/tests/lib/sorted-thread-list.result
--- aos_pintos/src/lib/build/tests/lib/sorted-thread-list.result	2024-02-09 02:53:31.500598943 +0000
+++ pintos-solution/src/lib/build/tests/lib/sorted-thread-list.result	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-PASS
diff -ruN aos_pintos/src/lib/build/tests/lib/unsorted-thread-list.output pintos-solution/src/lib/build/tests/lib/unsorted-thread-list.output
--- aos_pintos/src/lib/build/tests/lib/unsorted-thread-list.output	2024-02-09 02:53:31.992582235 +0000
+++ pintos-solution/src/lib/build/tests/lib/unsorted-thread-list.output	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-qemu-system-i386 -device isa-debug-exit -drive file=/tmp/isUgPNzLru.dsk,format=raw,index=0,media=disk -m 4 -net none -nographic -monitor null
-PiLo hda1
-Loading.........
-Kernel command line: -q run unsorted-thread-list
-Pintos booting with 3,968 kB RAM...
-367 pages available in kernel pool.
-367 pages available in user pool.
-Calibrating timer...  527,564,800 loops/s.
-Boot complete.
-Executing 'unsorted-thread-list':
-(unsorted-thread-list) begin
-(unsorted-thread-list) sorted index 6
-(unsorted-thread-list) end
-Execution of 'unsorted-thread-list' complete.
-Timer: 32 ticks
-Thread: 0 idle ticks, 32 kernel ticks, 0 user ticks
-Console: 455 characters output
-Keyboard: 0 keys pressed
-Powering off...
diff -ruN aos_pintos/src/lib/build/tests/lib/unsorted-thread-list.result pintos-solution/src/lib/build/tests/lib/unsorted-thread-list.result
--- aos_pintos/src/lib/build/tests/lib/unsorted-thread-list.result	2024-02-09 02:53:32.040580604 +0000
+++ pintos-solution/src/lib/build/tests/lib/unsorted-thread-list.result	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-PASS
diff -ruN aos_pintos/src/lib/build/threads/init.d pintos-solution/src/lib/build/threads/init.d
--- aos_pintos/src/lib/build/threads/init.d	2024-02-09 02:53:22.424907148 +0000
+++ pintos-solution/src/lib/build/threads/init.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,12 +0,0 @@
-threads/init.o: ../../threads/init.c ../../threads/init.h \
- ../../lib/debug.h ../../lib/stdbool.h ../../lib/stddef.h \
- ../../lib/stdint.h ../../lib/kernel/console.h ../../lib/inttypes.h \
- ../../lib/limits.h ../../lib/random.h ../../lib/stdio.h \
- ../../lib/stdarg.h ../../lib/kernel/stdio.h ../../lib/stdlib.h \
- ../../lib/string.h ../../devices/kbd.h ../../devices/input.h \
- ../../devices/serial.h ../../devices/shutdown.h ../../devices/timer.h \
- ../../lib/round.h ../../devices/vga.h ../../devices/rtc.h \
- ../../threads/interrupt.h ../../threads/io.h ../../threads/loader.h \
- ../../threads/malloc.h ../../threads/palloc.h ../../threads/pte.h \
- ../../threads/vaddr.h ../../threads/thread.h ../../lib/kernel/list.h \
- ../../tests/threads/tests.h
Binary files aos_pintos/src/lib/build/threads/init.o and pintos-solution/src/lib/build/threads/init.o differ
diff -ruN aos_pintos/src/lib/build/threads/interrupt.d pintos-solution/src/lib/build/threads/interrupt.d
--- aos_pintos/src/lib/build/threads/interrupt.d	2024-02-09 02:53:22.616900629 +0000
+++ pintos-solution/src/lib/build/threads/interrupt.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-threads/interrupt.o: ../../threads/interrupt.c ../../threads/interrupt.h \
- ../../lib/stdbool.h ../../lib/stdint.h ../../lib/debug.h \
- ../../lib/inttypes.h ../../lib/stdio.h ../../lib/stdarg.h \
- ../../lib/stddef.h ../../lib/kernel/stdio.h ../../threads/flags.h \
- ../../threads/intr-stubs.h ../../threads/io.h ../../threads/thread.h \
- ../../lib/kernel/list.h ../../threads/vaddr.h ../../threads/loader.h \
- ../../devices/timer.h ../../lib/round.h
Binary files aos_pintos/src/lib/build/threads/interrupt.o and pintos-solution/src/lib/build/threads/interrupt.o differ
diff -ruN aos_pintos/src/lib/build/threads/intr-stubs.d pintos-solution/src/lib/build/threads/intr-stubs.d
--- aos_pintos/src/lib/build/threads/intr-stubs.d	2024-02-09 02:53:22.632900086 +0000
+++ pintos-solution/src/lib/build/threads/intr-stubs.d	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-threads/intr-stubs.o: ../../threads/intr-stubs.S ../../threads/loader.h
Binary files aos_pintos/src/lib/build/threads/intr-stubs.o and pintos-solution/src/lib/build/threads/intr-stubs.o differ
diff -ruN aos_pintos/src/lib/build/threads/kernel.lds.s pintos-solution/src/lib/build/threads/kernel.lds.s
--- aos_pintos/src/lib/build/threads/kernel.lds.s	2024-02-09 02:53:22.348909730 +0000
+++ pintos-solution/src/lib/build/threads/kernel.lds.s	1970-01-01 00:00:00.000000000 +0000
@@ -1,21 +0,0 @@
-OUTPUT_FORMAT("elf32-i386")
-OUTPUT_ARCH("i386")
-ENTRY(start)
-SECTIONS
-{
-  _start = 0xc0000000 + 0x20000;
-  . = _start + SIZEOF_HEADERS;
-  .text : { *(.start) *(.text) } = 0x90
-  .rodata : { *(.rodata) *(.rodata.*)
-       . = ALIGN(0x1000);
-       _end_kernel_text = .; }
-  .eh_frame : { *(.eh_frame) }
-  .data : { *(.data)
-     _signature = .; LONG(0xaa55aa55) }
-  .plt : { *(.plt*) }
-  _start_bss = .;
-  .bss : { *(.bss) }
-  _end_bss = .;
-  _end = .;
-  ASSERT (_end - _start <= 512K, "Kernel image is too big.")
-}
Binary files aos_pintos/src/lib/build/threads/loader.o and pintos-solution/src/lib/build/threads/loader.o differ
diff -ruN aos_pintos/src/lib/build/threads/malloc.d pintos-solution/src/lib/build/threads/malloc.d
--- aos_pintos/src/lib/build/threads/malloc.d	2024-02-09 02:53:22.844892887 +0000
+++ pintos-solution/src/lib/build/threads/malloc.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-threads/malloc.o: ../../threads/malloc.c ../../threads/malloc.h \
- ../../lib/debug.h ../../lib/stddef.h ../../lib/kernel/list.h \
- ../../lib/stdbool.h ../../lib/stdint.h ../../lib/round.h \
- ../../lib/stdio.h ../../lib/stdarg.h ../../lib/kernel/stdio.h \
- ../../lib/string.h ../../threads/palloc.h ../../threads/synch.h \
- ../../threads/vaddr.h ../../threads/loader.h
Binary files aos_pintos/src/lib/build/threads/malloc.o and pintos-solution/src/lib/build/threads/malloc.o differ
diff -ruN aos_pintos/src/lib/build/threads/palloc.d pintos-solution/src/lib/build/threads/palloc.d
--- aos_pintos/src/lib/build/threads/palloc.d	2024-02-09 02:53:22.776895195 +0000
+++ pintos-solution/src/lib/build/threads/palloc.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-threads/palloc.o: ../../threads/palloc.c ../../threads/palloc.h \
- ../../lib/stddef.h ../../lib/kernel/bitmap.h ../../lib/stdbool.h \
- ../../lib/inttypes.h ../../lib/stdint.h ../../lib/debug.h \
- ../../lib/round.h ../../lib/stdio.h ../../lib/stdarg.h \
- ../../lib/kernel/stdio.h ../../lib/string.h ../../threads/loader.h \
- ../../threads/synch.h ../../lib/kernel/list.h ../../threads/vaddr.h
Binary files aos_pintos/src/lib/build/threads/palloc.o and pintos-solution/src/lib/build/threads/palloc.o differ
diff -ruN aos_pintos/src/lib/build/threads/start.d pintos-solution/src/lib/build/threads/start.d
--- aos_pintos/src/lib/build/threads/start.d	2024-02-09 02:53:22.352909594 +0000
+++ pintos-solution/src/lib/build/threads/start.d	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-threads/start.o: ../../threads/start.S ../../threads/loader.h
Binary files aos_pintos/src/lib/build/threads/start.o and pintos-solution/src/lib/build/threads/start.o differ
diff -ruN aos_pintos/src/lib/build/threads/switch.d pintos-solution/src/lib/build/threads/switch.d
--- aos_pintos/src/lib/build/threads/switch.d	2024-02-09 02:53:22.532903481 +0000
+++ pintos-solution/src/lib/build/threads/switch.d	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-threads/switch.o: ../../threads/switch.S ../../threads/switch.h
Binary files aos_pintos/src/lib/build/threads/switch.o and pintos-solution/src/lib/build/threads/switch.o differ
diff -ruN aos_pintos/src/lib/build/threads/synch.d pintos-solution/src/lib/build/threads/synch.d
--- aos_pintos/src/lib/build/threads/synch.d	2024-02-09 02:53:22.716897233 +0000
+++ pintos-solution/src/lib/build/threads/synch.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-threads/synch.o: ../../threads/synch.c ../../threads/synch.h \
- ../../lib/kernel/list.h ../../lib/stdbool.h ../../lib/stddef.h \
- ../../lib/stdint.h ../../lib/stdio.h ../../lib/debug.h \
- ../../lib/stdarg.h ../../lib/kernel/stdio.h ../../lib/string.h \
- ../../threads/interrupt.h ../../threads/thread.h
Binary files aos_pintos/src/lib/build/threads/synch.o and pintos-solution/src/lib/build/threads/synch.o differ
diff -ruN aos_pintos/src/lib/build/threads/thread.d pintos-solution/src/lib/build/threads/thread.d
--- aos_pintos/src/lib/build/threads/thread.d	2024-02-09 02:53:22.512904161 +0000
+++ pintos-solution/src/lib/build/threads/thread.d	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-threads/thread.o: ../../threads/thread.c ../../threads/thread.h \
- ../../lib/debug.h ../../lib/kernel/list.h ../../lib/stdbool.h \
- ../../lib/stddef.h ../../lib/stdint.h ../../lib/random.h \
- ../../lib/stdio.h ../../lib/stdarg.h ../../lib/kernel/stdio.h \
- ../../lib/string.h ../../threads/flags.h ../../threads/interrupt.h \
- ../../threads/intr-stubs.h ../../threads/palloc.h ../../threads/switch.h \
- ../../threads/synch.h ../../threads/vaddr.h ../../threads/loader.h
Binary files aos_pintos/src/lib/build/threads/thread.o and pintos-solution/src/lib/build/threads/thread.o differ
diff -ruN aos_pintos/src/lib/kernel/list.c pintos-solution/src/lib/kernel/list.c
--- aos_pintos/src/lib/kernel/list.c	2024-02-09 02:53:00.329657376 +0000
+++ pintos-solution/src/lib/kernel/list.c	2024-03-31 05:11:50.000000000 +0000
@@ -1,6 +1,5 @@
 #include "list.h"
 #include "../debug.h"
-#include "threads/thread.h"
 
 /* Our doubly linked lists have two header elements: the "head"
    just before the first element and the "tail" just after the
@@ -32,7 +31,6 @@
    elements allows us to do a little bit of checking on some
    operations, which can be valuable.) */
 
-
 static bool is_sorted (struct list_elem *a, struct list_elem *b,
                        list_less_func *less, void *aux) UNUSED;
 
@@ -313,29 +311,12 @@
     }
 }
 
-bool less_tid(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED) {  
-    return list_entry(a, struct thread, allelem)->tid < list_entry(b, struct thread, allelem)->tid;  
-}  
-
-int get_sorted_index (struct list *threads, struct thread *target) {  
-    if (threads == NULL || target == NULL)  
-        return -1;  
-      
-    list_sort(threads, less_tid, NULL);  
-    struct list_elem *e;  
-    int index = 0;  
-      
-    for (e = list_begin(threads); e != list_end(threads); e = list_next(e)) {  
-        struct thread *t = list_entry(e, struct thread, allelem);  
-        if (t->tid == target->tid) {  
-            return index;  
-        }  
-        index++;  
-    }  
-      
-    return -1;  
-}  
-
+int get_sorted_index (struct list *threads, struct thread *target) {
+  /* Your implementation here */
+  (void) threads;
+  (void) target;
+  return 0;
+}
 
 /* Returns true only if the list elements A through B (exclusive)
    are in order according to LESS given auxiliary data AUX. */
diff -ruN aos_pintos/src/tests/filesys/extended/Make.tests pintos-solution/src/tests/filesys/extended/Make.tests
--- aos_pintos/src/tests/filesys/extended/Make.tests	2024-02-09 01:26:31.467979510 +0000
+++ pintos-solution/src/tests/filesys/extended/Make.tests	2024-03-31 05:11:40.000000000 +0000
@@ -6,7 +6,10 @@
 grow-file-size grow-root-lg grow-root-sm grow-seq-lg grow-seq-sm	\
 grow-sparse grow-tell grow-two-files syn-rw
 
+add_tests = check-stat check-sparse
+
 tests/filesys/extended_TESTS = $(patsubst %,tests/filesys/extended/%,$(raw_tests))
+tests/filesys/extended_TESTS += $(patsubst %,tests/filesys/extended/%,$(add_tests))
 tests/filesys/extended_EXTRA_GRADES = $(patsubst %,tests/filesys/extended/%-persistence,$(raw_tests))
 
 tests/filesys/extended_PROGS = $(tests/filesys/extended_TESTS) \
diff -ruN aos_pintos/src/tests/filesys/extended/Rubric.functionality pintos-solution/src/tests/filesys/extended/Rubric.functionality
--- aos_pintos/src/tests/filesys/extended/Rubric.functionality	2024-02-09 01:26:31.515977395 +0000
+++ pintos-solution/src/tests/filesys/extended/Rubric.functionality	2024-03-31 05:11:42.000000000 +0000
@@ -24,3 +24,7 @@
 
 - Test writing from multiple processes.
 5	syn-rw
+
+- Test stat() and sparse files
+1	check-stat
+1	check-sparse
\ No newline at end of file
diff -ruN aos_pintos/src/tests/filesys/extended/check-sparse.c pintos-solution/src/tests/filesys/extended/check-sparse.c
--- aos_pintos/src/tests/filesys/extended/check-sparse.c	1970-01-01 00:00:00.000000000 +0000
+++ pintos-solution/src/tests/filesys/extended/check-sparse.c	2024-03-31 05:11:42.000000000 +0000
@@ -0,0 +1,61 @@
+/* Ensure that disk blocks aren't being allocated
+   until file explicitly written to for sparse
+   files implementation. */
+
+#include <random.h>
+#include <stdio.h>
+#include <syscall.h>
+#include "tests/lib.h"
+#include "tests/main.h"
+
+void test_main (void)
+{
+  const unsigned int BUF_SIZE = 16;
+  const char FILE_NAME[] = "yoit";
+  int fd;
+  int ret;
+  char buf[BUF_SIZE];
+
+  int exp_log_size = 512;
+  int exp_phys_size = 0;
+  int exp_blocks = 0;
+
+  // Create file
+  CHECK (create (FILE_NAME, exp_log_size), "create \"%s\"", FILE_NAME);
+  CHECK ((fd = open (FILE_NAME)) > 1, "open \"%s\"", FILE_NAME);
+  CHECK ((ret = stat (FILE_NAME, buf)) == 0,
+         "return 0 from stat() call on \"%s\"", FILE_NAME);
+
+  // Check initial file status
+  int logical_size = *((int *) buf);
+  int physical_size = *((int *) buf + 1);
+  int inode_number = *((int *) buf + 2);
+  int blocks = *((int *) buf + 3);
+
+  msg ("should have %d logical size: actual %d", exp_log_size, logical_size);
+  msg ("should have %d physical size: actual %d", exp_phys_size, physical_size);
+  CHECK (inode_number > 0, "valid inode number");
+  msg ("should have %d block: actual %d", exp_blocks, blocks);
+
+  // Now let's write some random, non-zero bytes and check file status
+  const int RAND_BYTES = 500;
+  char buf1[RAND_BYTES];
+  random_bytes (buf1, RAND_BYTES);
+  CHECK (write (fd, buf1, RAND_BYTES), "write random bytes to \"%s\"",
+         FILE_NAME);
+  CHECK ((ret = stat (FILE_NAME, buf)) == 0,
+         "return 0 from stat() call on \"%s\"", FILE_NAME);
+
+  exp_phys_size = 500;
+  exp_blocks = 1;
+
+  logical_size = *((int *) buf);
+  physical_size = *((int *) buf + 1);
+  inode_number = *((int *) buf + 2);
+  blocks = *((int *) buf + 3);
+
+  msg ("should have %d logical size: actual %d", exp_log_size, logical_size);
+  msg ("should have %d physical size: actual %d", exp_phys_size, physical_size);
+  CHECK (inode_number > 0, "valid inode number");
+  msg ("should have %d block: actual %d", exp_blocks, blocks);
+}
\ No newline at end of file
diff -ruN aos_pintos/src/tests/filesys/extended/check-sparse.ck pintos-solution/src/tests/filesys/extended/check-sparse.ck
--- aos_pintos/src/tests/filesys/extended/check-sparse.ck	1970-01-01 00:00:00.000000000 +0000
+++ pintos-solution/src/tests/filesys/extended/check-sparse.ck	2024-03-31 05:11:40.000000000 +0000
@@ -0,0 +1,22 @@
+# -*- perl -*-
+use strict;
+use warnings;
+use tests::tests;
+check_expected (IGNORE_EXIT_CODES => 1, [<<'EOF']);
+(check-sparse) begin
+(check-sparse) create "yoit"
+(check-sparse) open "yoit"
+(check-sparse) return 0 from stat() call on "yoit"
+(check-sparse) should have 512 logical size: actual 512
+(check-sparse) should have 0 physical size: actual 0
+(check-sparse) valid inode number
+(check-sparse) should have 0 block: actual 0
+(check-sparse) write random bytes to "yoit"
+(check-sparse) return 0 from stat() call on "yoit"
+(check-sparse) should have 512 logical size: actual 512
+(check-sparse) should have 500 physical size: actual 500
+(check-sparse) valid inode number
+(check-sparse) should have 1 block: actual 1
+(check-sparse) end
+EOF
+pass;
diff -ruN aos_pintos/src/tests/filesys/extended/check-stat.c pintos-solution/src/tests/filesys/extended/check-stat.c
--- aos_pintos/src/tests/filesys/extended/check-stat.c	1970-01-01 00:00:00.000000000 +0000
+++ pintos-solution/src/tests/filesys/extended/check-stat.c	2024-03-31 05:11:40.000000000 +0000
@@ -0,0 +1,36 @@
+/* Checks basic functionality of stat() system call. */
+
+#include <random.h>
+#include <stdio.h>
+#include <syscall.h>
+#include "tests/lib.h"
+#include "tests/main.h"
+
+void test_main (void)
+{
+  const unsigned int BUF_SIZE = 16;
+  const char FILE_NAME[] = "yoit";
+  int fd;
+  int ret;
+  char buf[BUF_SIZE];
+
+  int exp_log_size = 512;
+  int exp_phys_size = 0;
+  int exp_blocks = 0;
+
+  // Create file and check file status
+  CHECK (create (FILE_NAME, exp_log_size), "create \"%s\"", FILE_NAME);
+  CHECK ((fd = open (FILE_NAME)) > 1, "open \"%s\"", FILE_NAME);
+  CHECK ((ret = stat (FILE_NAME, buf)) == 0,
+         "return 0 from stat() call on \"%s\"", FILE_NAME);
+
+  int logical_size = *((int *) buf);
+  int physical_size = *((int *) buf + 1);
+  int inode_number = *((int *) buf + 2);
+  int blocks = *((int *) buf + 3);
+
+  msg ("should have %d logical size: actual %d", exp_log_size, logical_size);
+  msg ("should have %d physical size: actual %d", exp_phys_size, physical_size);
+  CHECK (inode_number > 0, "valid inode number");
+  msg ("should have %d block: actual %d", exp_blocks, blocks);
+}
\ No newline at end of file
diff -ruN aos_pintos/src/tests/filesys/extended/check-stat.ck pintos-solution/src/tests/filesys/extended/check-stat.ck
--- aos_pintos/src/tests/filesys/extended/check-stat.ck	1970-01-01 00:00:00.000000000 +0000
+++ pintos-solution/src/tests/filesys/extended/check-stat.ck	2024-03-31 05:11:40.000000000 +0000
@@ -0,0 +1,16 @@
+# -*- perl -*-
+use strict;
+use warnings;
+use tests::tests;
+check_expected (IGNORE_EXIT_CODES => 1, [<<'EOF']);
+(check-stat) begin
+(check-stat) create "yoit"
+(check-stat) open "yoit"
+(check-stat) return 0 from stat() call on "yoit"
+(check-stat) should have 512 logical size: actual 512
+(check-stat) should have 0 physical size: actual 0
+(check-stat) valid inode number
+(check-stat) should have 0 block: actual 0
+(check-stat) end
+EOF
+pass;
diff -ruN aos_pintos/src/tests/threads/Make.tests pintos-solution/src/tests/threads/Make.tests
--- aos_pintos/src/tests/threads/Make.tests	2024-02-09 01:26:31.699969288 +0000
+++ pintos-solution/src/tests/threads/Make.tests	2024-03-31 05:11:44.000000000 +0000
@@ -4,14 +4,13 @@
 tests/threads_TESTS = $(addprefix tests/threads/,alarm-single		\
 alarm-multiple alarm-simultaneous alarm-priority alarm-zero		\
 alarm-negative priority-change priority-donate-one			\
-priority-donate-one-sema        \
-priority-donate-multiple priority-donate-multiple-sema      \
+priority-donate-multiple       \
 priority-donate-multiple2			\
-priority-donate-nest priority-donate-nest-sema          \
+priority-donate-nest           \
 priority-donate-sema       \
-priority-donate-lower priority-donate-lower-sema		\
+priority-donate-lower 		\
 priority-fifo priority-preempt priority-sema priority-condvar		\
-priority-donate-chain priority-donate-chain-sema)
+priority-donate-chain )
 
 # Sources for tests.
 tests/threads_SRC  = tests/threads/tests.c
@@ -22,20 +21,14 @@
 tests/threads_SRC += tests/threads/alarm-negative.c
 tests/threads_SRC += tests/threads/priority-change.c
 tests/threads_SRC += tests/threads/priority-donate-one.c
-tests/threads_SRC += tests/threads/priority-donate-one-sema.c
 tests/threads_SRC += tests/threads/priority-donate-multiple.c
-tests/threads_SRC += tests/threads/priority-donate-multiple-sema.c
 tests/threads_SRC += tests/threads/priority-donate-multiple2.c
 tests/threads_SRC += tests/threads/priority-donate-nest.c
-tests/threads_SRC += tests/threads/priority-donate-nest-sema.c
 tests/threads_SRC += tests/threads/priority-donate-sema.c
 tests/threads_SRC += tests/threads/priority-donate-lower.c
-tests/threads_SRC += tests/threads/priority-donate-lower-sema.c
 tests/threads_SRC += tests/threads/priority-fifo.c
 tests/threads_SRC += tests/threads/priority-preempt.c
 tests/threads_SRC += tests/threads/priority-sema.c
 tests/threads_SRC += tests/threads/priority-condvar.c
 tests/threads_SRC += tests/threads/priority-donate-chain.c
-tests/threads_SRC += tests/threads/priority-donate-chain-sema.c
-
 
diff -ruN aos_pintos/src/tests/threads/priority-donate-chain-sema.c pintos-solution/src/tests/threads/priority-donate-chain-sema.c
--- aos_pintos/src/tests/threads/priority-donate-chain-sema.c	2024-02-09 01:26:31.723968230 +0000
+++ pintos-solution/src/tests/threads/priority-donate-chain-sema.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,107 +0,0 @@
-/* The main thread set its priority to PRI_MIN and creates 7 threads
-   (thread 1..7) with priorities PRI_MIN + 3, 6, 9, 12, ...
-   The main thread initializes 8 locks: lock 0..7 and acquires lock 0.
-
-   When thread[i] starts, it first acquires lock[i] (unless i == 7.)
-   Subsequently, thread[i] attempts to acquire lock[i-1], which is held by
-   thread[i-1], except for lock[0], which is held by the main thread.
-   Because the lock is held, thread[i] donates its priority to thread[i-1],
-   which donates to thread[i-2], and so on until the main thread
-   receives the donation.
-
-   After threads[1..7] have been created and are blocked on locks[0..7],
-   the main thread releases lock[0], unblocking thread[1], and being
-   preempted by it.
-   Thread[1] then completes acquiring lock[0], then releases lock[0],
-   then releases lock[1], unblocking thread[2], etc.
-   Thread[7] finally acquires & releases lock[7] and exits, allowing
-   thread[6], then thread[5] etc. to run and exit until finally the
-   main thread exits.
-
-   In addition, interloper threads are created at priority levels
-   p = PRI_MIN + 2, 5, 8, 11, ... which should not be run until the
-   corresponding thread with priority p + 1 has finished.
-
-   Written by Godmar Back <gback@cs.vt.edu> */
-
-#include <stdio.h>
-#include "tests/threads/tests.h"
-#include "threads/init.h"
-#include "threads/synch.h"
-#include "threads/thread.h"
-
-#define NESTING_DEPTH 8
-
-struct sema_pair
-{
-  struct semaphore *second;
-  struct semaphore *first;
-};
-
-static thread_func donor_thread_func;
-static thread_func interloper_thread_func;
-
-void test_priority_donate_chain_sema (void)
-{
-  int i;
-  struct semaphore semas[NESTING_DEPTH - 1];
-  struct sema_pair sema_pairs[NESTING_DEPTH];
-
-  thread_set_priority (PRI_MIN);
-
-  for (i = 0; i < NESTING_DEPTH - 1; i++)
-    sema_init (&semas[i], 1);
-
-  sema_down (&semas[0]);
-  msg ("%s downed semaphore.", thread_name ());
-
-  for (i = 1; i < NESTING_DEPTH; i++)
-    {
-      char name[16];
-      int thread_priority;
-
-      snprintf (name, sizeof name, "thread %d", i);
-      thread_priority = PRI_MIN + i * 3;
-      sema_pairs[i].first = i < NESTING_DEPTH - 1 ? semas + i : NULL;
-      sema_pairs[i].second = semas + i - 1;
-
-      thread_create (name, thread_priority, donor_thread_func, sema_pairs + i);
-      msg ("%s should have priority %d.  Actual priority: %d.", thread_name (),
-           thread_priority, thread_get_priority ());
-
-      snprintf (name, sizeof name, "interloper %d", i);
-      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
-    }
-
-  sema_up (&semas[0]);
-  msg ("%s finishing with priority %d.", thread_name (),
-       thread_get_priority ());
-}
-
-static void donor_thread_func (void *semas_)
-{
-  struct sema_pair *semas = semas_;
-
-  if (semas->first)
-    sema_down (semas->first);
-
-  sema_down (semas->second);
-  msg ("%s downed semaphore", thread_name ());
-
-  sema_up (semas->second);
-  msg ("%s should have priority %d. Actual priority: %d", thread_name (),
-       (NESTING_DEPTH - 1) * 3, thread_get_priority ());
-
-  if (semas->first)
-    sema_up (semas->first);
-
-  msg ("%s finishing with priority %d.", thread_name (),
-       thread_get_priority ());
-}
-
-static void interloper_thread_func (void *arg_ UNUSED)
-{
-  msg ("%s finished.", thread_name ());
-}
-
-// vim: sw=2
diff -ruN aos_pintos/src/tests/threads/priority-donate-chain-sema.ck pintos-solution/src/tests/threads/priority-donate-chain-sema.ck
--- aos_pintos/src/tests/threads/priority-donate-chain-sema.ck	2024-02-09 01:26:31.727968054 +0000
+++ pintos-solution/src/tests/threads/priority-donate-chain-sema.ck	1970-01-01 00:00:00.000000000 +0000
@@ -1,46 +0,0 @@
-# -*- perl -*-
-use strict;
-use warnings;
-use tests::tests;
-check_expected ([<<'EOF']);
-(priority-donate-chain-sema) begin
-(priority-donate-chain-sema) main downed semaphore.
-(priority-donate-chain-sema) main should have priority 3.  Actual priority: 3.
-(priority-donate-chain-sema) main should have priority 6.  Actual priority: 6.
-(priority-donate-chain-sema) main should have priority 9.  Actual priority: 9.
-(priority-donate-chain-sema) main should have priority 12.  Actual priority: 12.
-(priority-donate-chain-sema) main should have priority 15.  Actual priority: 15.
-(priority-donate-chain-sema) main should have priority 18.  Actual priority: 18.
-(priority-donate-chain-sema) main should have priority 21.  Actual priority: 21.
-(priority-donate-chain-sema) thread 1 downed semaphore
-(priority-donate-chain-sema) thread 1 should have priority 21. Actual priority: 21
-(priority-donate-chain-sema) thread 2 downed semaphore
-(priority-donate-chain-sema) thread 2 should have priority 21. Actual priority: 21
-(priority-donate-chain-sema) thread 3 downed semaphore
-(priority-donate-chain-sema) thread 3 should have priority 21. Actual priority: 21
-(priority-donate-chain-sema) thread 4 downed semaphore
-(priority-donate-chain-sema) thread 4 should have priority 21. Actual priority: 21
-(priority-donate-chain-sema) thread 5 downed semaphore
-(priority-donate-chain-sema) thread 5 should have priority 21. Actual priority: 21
-(priority-donate-chain-sema) thread 6 downed semaphore
-(priority-donate-chain-sema) thread 6 should have priority 21. Actual priority: 21
-(priority-donate-chain-sema) thread 7 downed semaphore
-(priority-donate-chain-sema) thread 7 should have priority 21. Actual priority: 21
-(priority-donate-chain-sema) thread 7 finishing with priority 21.
-(priority-donate-chain-sema) interloper 7 finished.
-(priority-donate-chain-sema) thread 6 finishing with priority 18.
-(priority-donate-chain-sema) interloper 6 finished.
-(priority-donate-chain-sema) thread 5 finishing with priority 15.
-(priority-donate-chain-sema) interloper 5 finished.
-(priority-donate-chain-sema) thread 4 finishing with priority 12.
-(priority-donate-chain-sema) interloper 4 finished.
-(priority-donate-chain-sema) thread 3 finishing with priority 9.
-(priority-donate-chain-sema) interloper 3 finished.
-(priority-donate-chain-sema) thread 2 finishing with priority 6.
-(priority-donate-chain-sema) interloper 2 finished.
-(priority-donate-chain-sema) thread 1 finishing with priority 3.
-(priority-donate-chain-sema) interloper 1 finished.
-(priority-donate-chain-sema) main finishing with priority 0.
-(priority-donate-chain-sema) end
-EOF
-pass;
diff -ruN aos_pintos/src/tests/threads/priority-donate-lower-sema.c pintos-solution/src/tests/threads/priority-donate-lower-sema.c
--- aos_pintos/src/tests/threads/priority-donate-lower-sema.c	2024-02-09 01:26:31.715968583 +0000
+++ pintos-solution/src/tests/threads/priority-donate-lower-sema.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,46 +0,0 @@
-/* The main thread downs a semaphore.  Then it creates a
-   higher-priority thread that blocks being able to down the semaphore
-   again, causing it to donate its priority to the main thread.  The main
-   thread attempts to lower its priority, which should not take
-   effect until the donation is released. */
-
-#include <stdio.h>
-#include "tests/threads/tests.h"
-#include "threads/init.h"
-#include "threads/synch.h"
-#include "threads/thread.h"
-
-static thread_func down_thread_func;
-
-void test_priority_donate_lower_sema (void)
-{
-  struct semaphore sema;
-
-  /* Make sure our priority is the default. */
-  ASSERT (thread_get_priority () == PRI_DEFAULT);
-
-  sema_init (&sema, 1);
-  sema_down (&sema);
-  thread_create ("down", PRI_DEFAULT + 10, down_thread_func, &sema);
-  msg ("Main thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 10, thread_get_priority ());
-
-  msg ("Lowering base priority...");
-  thread_set_priority (PRI_DEFAULT - 10);
-  msg ("Main thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 10, thread_get_priority ());
-  sema_up (&sema);
-  msg ("down must already have finished.");
-  msg ("Main thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT - 10, thread_get_priority ());
-}
-
-static void down_thread_func (void *sema_)
-{
-  struct semaphore *sema = sema_;
-
-  sema_down (sema);
-  msg ("down: downed the semaphore");
-  sema_up (sema);
-  msg ("down: done");
-}
diff -ruN aos_pintos/src/tests/threads/priority-donate-lower-sema.ck pintos-solution/src/tests/threads/priority-donate-lower-sema.ck
--- aos_pintos/src/tests/threads/priority-donate-lower-sema.ck	2024-02-09 01:26:31.695969464 +0000
+++ pintos-solution/src/tests/threads/priority-donate-lower-sema.ck	1970-01-01 00:00:00.000000000 +0000
@@ -1,16 +0,0 @@
-# -*- perl -*-
-use strict;
-use warnings;
-use tests::tests;
-check_expected ([<<'EOF']);
-(priority-donate-lower-sema) begin
-(priority-donate-lower-sema) Main thread should have priority 41.  Actual priority: 41.
-(priority-donate-lower-sema) Lowering base priority...
-(priority-donate-lower-sema) Main thread should have priority 41.  Actual priority: 41.
-(priority-donate-lower-sema) down: downed the semaphore
-(priority-donate-lower-sema) down: done
-(priority-donate-lower-sema) down must already have finished.
-(priority-donate-lower-sema) Main thread should have priority 21.  Actual priority: 21.
-(priority-donate-lower-sema) end
-EOF
-pass;
diff -ruN aos_pintos/src/tests/threads/priority-donate-multiple-sema.c pintos-solution/src/tests/threads/priority-donate-multiple-sema.c
--- aos_pintos/src/tests/threads/priority-donate-multiple-sema.c	2024-02-09 01:26:31.687969816 +0000
+++ pintos-solution/src/tests/threads/priority-donate-multiple-sema.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,67 +0,0 @@
-/* The main thread downs semaphores A and B, then it creates two
-   higher-priority threads.  Each of these threads blocks
-   being able to down one of the semaphores again and thus donate
-   their priority to the main thread.  The main thread ups the semaphores
-   in turn and relinquishes its donated priorities.
-*/
-
-#include <stdio.h>
-#include "tests/threads/tests.h"
-#include "threads/init.h"
-#include "threads/synch.h"
-#include "threads/thread.h"
-
-static thread_func a_thread_func;
-static thread_func b_thread_func;
-
-void test_priority_donate_multiple_sema (void)
-{
-  struct semaphore a, b;
-
-  /* Make sure our priority is the default. */
-  ASSERT (thread_get_priority () == PRI_DEFAULT);
-
-  sema_init (&a, 1);
-  sema_init (&b, 1);
-
-  sema_down (&a);
-  sema_down (&b);
-
-  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
-  msg ("Main thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 1, thread_get_priority ());
-
-  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
-  msg ("Main thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 2, thread_get_priority ());
-
-  sema_up (&b);
-  msg ("Thread b should have just finished.");
-  msg ("Main thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 1, thread_get_priority ());
-
-  sema_up (&a);
-  msg ("Thread a should have just finished.");
-  msg ("Main thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT, thread_get_priority ());
-}
-
-static void a_thread_func (void *sema_)
-{
-  struct semaphore *sema = sema_;
-
-  sema_down (sema);
-  msg ("Thread a downed semaphore a.");
-  sema_up (sema);
-  msg ("Thread a finished.");
-}
-
-static void b_thread_func (void *sema_)
-{
-  struct semaphore *sema = sema_;
-
-  sema_down (sema);
-  msg ("Thread b downed semaphore b.");
-  sema_up (sema);
-  msg ("Thread b finished.");
-}
diff -ruN aos_pintos/src/tests/threads/priority-donate-multiple-sema.ck pintos-solution/src/tests/threads/priority-donate-multiple-sema.ck
--- aos_pintos/src/tests/threads/priority-donate-multiple-sema.ck	2024-02-09 01:26:31.703969112 +0000
+++ pintos-solution/src/tests/threads/priority-donate-multiple-sema.ck	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-# -*- perl -*-
-use strict;
-use warnings;
-use tests::tests;
-check_expected ([<<'EOF']);
-(priority-donate-multiple-sema) begin
-(priority-donate-multiple-sema) Main thread should have priority 32.  Actual priority: 32.
-(priority-donate-multiple-sema) Main thread should have priority 33.  Actual priority: 33.
-(priority-donate-multiple-sema) Thread b downed semaphore b.
-(priority-donate-multiple-sema) Thread b finished.
-(priority-donate-multiple-sema) Thread b should have just finished.
-(priority-donate-multiple-sema) Main thread should have priority 32.  Actual priority: 32.
-(priority-donate-multiple-sema) Thread a downed semaphore a.
-(priority-donate-multiple-sema) Thread a finished.
-(priority-donate-multiple-sema) Thread a should have just finished.
-(priority-donate-multiple-sema) Main thread should have priority 31.  Actual priority: 31.
-(priority-donate-multiple-sema) end
-EOF
-pass;
diff -ruN aos_pintos/src/tests/threads/priority-donate-nest-sema.c pintos-solution/src/tests/threads/priority-donate-nest-sema.c
--- aos_pintos/src/tests/threads/priority-donate-nest-sema.c	2024-02-09 01:26:31.707968935 +0000
+++ pintos-solution/src/tests/threads/priority-donate-nest-sema.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,84 +0,0 @@
-/* Low-priority main thread L downs semaphore A.  Medium-priority
-   thread M then downs semaphore B, but is blocked from being able to down 
-   semaphore A again. High-priority thread H is blocked from being able
-   to down semaphore B again.  Thus, thread H donates its priority to M,
-   which in turn donates it to thread L.
- */
-
-#include <stdio.h>
-#include "tests/threads/tests.h"
-#include "threads/init.h"
-#include "threads/synch.h"
-#include "threads/thread.h"
-
-struct semas
-{
-  struct semaphore *a;
-  struct semaphore *b;
-};
-
-static thread_func medium_thread_func;
-static thread_func high_thread_func;
-
-void test_priority_donate_nest_sema (void)
-{
-  struct semaphore a, b;
-  struct semas semas;
-
-  /* Make sure our priority is the default. */
-  ASSERT (thread_get_priority () == PRI_DEFAULT);
-
-  sema_init (&a, 1);
-  sema_init (&b, 1);
-
-  sema_down (&a);
-
-  semas.a = &a;
-  semas.b = &b;
-  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &semas);
-  thread_yield ();
-  msg ("Low thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 1, thread_get_priority ());
-
-  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
-  thread_yield ();
-  msg ("Low thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 2, thread_get_priority ());
-
-  sema_up (&a);
-  thread_yield ();
-  msg ("Medium thread should just have finished.");
-  msg ("Low thread should have priority %d.  Actual priority: %d.", PRI_DEFAULT,
-       thread_get_priority ());
-}
-
-static void medium_thread_func (void *semas_)
-{
-  struct semas *semas = semas_;
-
-  sema_down (semas->b);
-  sema_down (semas->a);
-
-  msg ("Medium thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 2, thread_get_priority ());
-  msg ("Medium thread downed the semaphores.");
-
-  sema_up (semas->a);
-  thread_yield ();
-
-  sema_up (semas->b);
-  thread_yield ();
-
-  msg ("High thread should have just finished.");
-  msg ("Middle thread finished.");
-}
-
-static void high_thread_func (void *sema_)
-{
-  struct semaphore *sema = sema_;
-
-  sema_down (sema);
-  msg ("High thread downed the semaphore.");
-  sema_up (sema);
-  msg ("High thread finished.");
-}
diff -ruN aos_pintos/src/tests/threads/priority-donate-nest-sema.ck pintos-solution/src/tests/threads/priority-donate-nest-sema.ck
--- aos_pintos/src/tests/threads/priority-donate-nest-sema.ck	2024-02-09 01:26:31.711968759 +0000
+++ pintos-solution/src/tests/threads/priority-donate-nest-sema.ck	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-# -*- perl -*-
-use strict;
-use warnings;
-use tests::tests;
-check_expected ([<<'EOF']);
-(priority-donate-nest-sema) begin
-(priority-donate-nest-sema) Low thread should have priority 32.  Actual priority: 32.
-(priority-donate-nest-sema) Low thread should have priority 33.  Actual priority: 33.
-(priority-donate-nest-sema) Medium thread should have priority 33.  Actual priority: 33.
-(priority-donate-nest-sema) Medium thread downed the semaphores.
-(priority-donate-nest-sema) High thread downed the semaphore.
-(priority-donate-nest-sema) High thread finished.
-(priority-donate-nest-sema) High thread should have just finished.
-(priority-donate-nest-sema) Middle thread finished.
-(priority-donate-nest-sema) Medium thread should just have finished.
-(priority-donate-nest-sema) Low thread should have priority 31.  Actual priority: 31.
-(priority-donate-nest-sema) end
-EOF
-pass;
diff -ruN aos_pintos/src/tests/threads/priority-donate-one-sema.c pintos-solution/src/tests/threads/priority-donate-one-sema.c
--- aos_pintos/src/tests/threads/priority-donate-one-sema.c	2024-02-09 01:26:31.675970345 +0000
+++ pintos-solution/src/tests/threads/priority-donate-one-sema.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,55 +0,0 @@
-/* The main thread creates and downs a binary semaphore.  Then it creates two
-   higher-priority threads that block being able to down the semaphore again,
-   causing them to donate their priorities to the main thread.  When the
-   main thread ups the semaphore, the other threads should
-   down it in priority order.
- */
-
-#include <stdio.h>
-#include "tests/threads/tests.h"
-#include "threads/init.h"
-#include "threads/synch.h"
-#include "threads/thread.h"
-
-static thread_func down1_thread_func;
-static thread_func down2_thread_func;
-
-void test_priority_donate_one_sema (void)
-{
-  struct semaphore sema;
-
-  /* Make sure our priority is the default. */
-  ASSERT (thread_get_priority () == PRI_DEFAULT);
-
-  sema_init (&sema, 1);
-  sema_down (&sema);
-  thread_create ("down1", PRI_DEFAULT + 1, down1_thread_func, &sema);
-  msg ("This thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 1, thread_get_priority ());
-  thread_create ("down2", PRI_DEFAULT + 2, down2_thread_func, &sema);
-  msg ("This thread should have priority %d.  Actual priority: %d.",
-       PRI_DEFAULT + 2, thread_get_priority ());
-  sema_up (&sema);
-  msg ("down2, down1 must already have finished, in that order.");
-  msg ("This should be the last line before finishing this test.");
-}
-
-static void down1_thread_func (void *sema_)
-{
-  struct semaphore *sema = sema_;
-
-  sema_down (sema);
-  msg ("down1: downed the semaphore");
-  sema_up (sema);
-  msg ("down1: done");
-}
-
-static void down2_thread_func (void *sema_)
-{
-  struct semaphore *sema = sema_;
-
-  sema_down (sema);
-  msg ("down2: downed the semaphore");
-  sema_up (sema);
-  msg ("down2: done");
-}
diff -ruN aos_pintos/src/tests/threads/priority-donate-one-sema.ck pintos-solution/src/tests/threads/priority-donate-one-sema.ck
--- aos_pintos/src/tests/threads/priority-donate-one-sema.ck	2024-02-09 01:26:31.707968935 +0000
+++ pintos-solution/src/tests/threads/priority-donate-one-sema.ck	1970-01-01 00:00:00.000000000 +0000
@@ -1,17 +0,0 @@
-# -*- perl -*-
-use strict;
-use warnings;
-use tests::tests;
-check_expected ([<<'EOF']);
-(priority-donate-one-sema) begin
-(priority-donate-one-sema) This thread should have priority 32.  Actual priority: 32.
-(priority-donate-one-sema) This thread should have priority 33.  Actual priority: 33.
-(priority-donate-one-sema) down2: downed the semaphore
-(priority-donate-one-sema) down2: done
-(priority-donate-one-sema) down1: downed the semaphore
-(priority-donate-one-sema) down1: done
-(priority-donate-one-sema) down2, down1 must already have finished, in that order.
-(priority-donate-one-sema) This should be the last line before finishing this test.
-(priority-donate-one-sema) end
-EOF
-pass;
diff -ruN aos_pintos/src/tests/threads/tests.c pintos-solution/src/tests/threads/tests.c
--- aos_pintos/src/tests/threads/tests.c	2024-02-09 01:26:31.699969288 +0000
+++ pintos-solution/src/tests/threads/tests.c	2024-03-31 05:11:44.000000000 +0000
@@ -18,17 +18,12 @@
     {"alarm-negative", test_alarm_negative},
     {"priority-change", test_priority_change},
     {"priority-donate-one", test_priority_donate_one},
-    {"priority-donate-one-sema", test_priority_donate_one_sema},
     {"priority-donate-multiple", test_priority_donate_multiple},
-    {"priority-donate-multiple-sema", test_priority_donate_multiple_sema},
     {"priority-donate-multiple2", test_priority_donate_multiple2},
     {"priority-donate-nest", test_priority_donate_nest},
-    {"priority-donate-nest-sema", test_priority_donate_nest_sema},
     {"priority-donate-sema", test_priority_donate_sema},
     {"priority-donate-lower", test_priority_donate_lower},
-    {"priority-donate-lower-sema", test_priority_donate_lower_sema},
     {"priority-donate-chain", test_priority_donate_chain},
-    {"priority-donate-chain-sema", test_priority_donate_chain_sema},
     {"priority-fifo", test_priority_fifo},
     {"priority-preempt", test_priority_preempt},
     {"priority-sema", test_priority_sema},
diff -ruN aos_pintos/src/tests/threads/tests.h pintos-solution/src/tests/threads/tests.h
--- aos_pintos/src/tests/threads/tests.h	2024-02-09 01:26:31.675970345 +0000
+++ pintos-solution/src/tests/threads/tests.h	2024-03-31 05:11:44.000000000 +0000
@@ -13,17 +13,12 @@
 extern test_func test_alarm_negative;
 extern test_func test_priority_change;
 extern test_func test_priority_donate_one;
-extern test_func test_priority_donate_one_sema;
 extern test_func test_priority_donate_multiple;
-extern test_func test_priority_donate_multiple_sema;
 extern test_func test_priority_donate_multiple2;
 extern test_func test_priority_donate_sema;
 extern test_func test_priority_donate_nest;
-extern test_func test_priority_donate_nest_sema;
 extern test_func test_priority_donate_lower;
-extern test_func test_priority_donate_lower_sema;
 extern test_func test_priority_donate_chain;
-extern test_func test_priority_donate_chain_sema;
 extern test_func test_priority_fifo;
 extern test_func test_priority_preempt;
 extern test_func test_priority_sema;
diff -ruN aos_pintos/src/tests/userprog/Rubric.functionality pintos-solution/src/tests/userprog/Rubric.functionality
--- aos_pintos/src/tests/userprog/Rubric.functionality	2024-02-09 01:26:31.995956245 +0000
+++ pintos-solution/src/tests/userprog/Rubric.functionality	2024-03-31 05:11:46.000000000 +0000
@@ -44,10 +44,10 @@
 3	halt
 
 - Test "symlink" system call.
-5   symlink-bad-target
-5   symlink-check
-5   symlink-remove
-10  symlink-read
+5	sl-bad-target
+5	sl-check
+5	sl-remove
+10	sl-read
 
 - Test recursive execution of user programs.
 15	multi-recurse
diff -ruN aos_pintos/src/tests/userprog/sl-read.c pintos-solution/src/tests/userprog/sl-read.c
--- aos_pintos/src/tests/userprog/sl-read.c	2024-02-09 01:26:31.771966115 +0000
+++ pintos-solution/src/tests/userprog/sl-read.c	2024-03-31 05:11:44.000000000 +0000
@@ -27,12 +27,11 @@
   CHECK ((link_fd = open ("test-link.txt")) > 1, "open \"test-link.txt\"");
 
   char content[] = "This is a test";
-  CHECK (write (target_fd, content, sizeof content - 1) == sizeof content - 1,
+  CHECK (write (target_fd, content, sizeof content) == sizeof content,
          "write content to \"test.txt\"");
   char buf[sizeof content];
-  CHECK (read (link_fd, buf, sizeof content - 1) == sizeof content - 1,
+  CHECK (read (link_fd, buf, sizeof content) == sizeof content,
          "read \"test-link.txt\"");
 
-  buf[sizeof content] = '\0';
   msg ("test-link.txt reads: '%s'", buf);
-}
+}
\ No newline at end of file
diff -ruN aos_pintos/src/threads/palloc.c pintos-solution/src/threads/palloc.c
--- aos_pintos/src/threads/palloc.c	2024-02-09 01:26:32.155949199 +0000
+++ pintos-solution/src/threads/palloc.c	2024-03-31 05:11:48.000000000 +0000
@@ -147,7 +147,8 @@
 {
   /* We'll put the pool's used_map at its base.
      Calculate the space needed for the bitmap
-     and subtract it from the pool's size. */
+     and subtract it from the pool's size. 
+     [placeholder] - it is turtles all the way down */
   size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
   if (bm_pages > page_cnt)
     PANIC ("Not enough memory in %s for bitmap.", name);
diff -ruN aos_pintos/src/threads/thread.c pintos-solution/src/threads/thread.c
--- aos_pintos/src/threads/thread.c	2024-02-09 01:26:32.143949727 +0000
+++ pintos-solution/src/threads/thread.c	2024-03-31 05:11:48.000000000 +0000
@@ -11,8 +11,13 @@
 #include "threads/switch.h"
 #include "threads/synch.h"
 #include "threads/vaddr.h"
+#include "lib/kernel/stdio.h"
+#include "threads/malloc.h"
+#include "userprog/process.h"
 #ifdef USERPROG
 #include "userprog/process.h"
+#include "filesys/filesys.h"
+#include "filesys/file.h"
 #endif
 
 /* Random value for struct thread's `magic' member.
@@ -193,6 +198,30 @@
   sf->eip = switch_entry;
   sf->ebp = 0;
 
+  t->parent = thread_current (); // Creating thread is parent of new thread
+
+  // Add new thread to children struct of parent
+  struct child *child = malloc (sizeof (struct child));
+  child->child_thread = t;
+  child->exit_status = -1;
+  child->pid = tid;
+  sema_init(&child->exited, 0);
+  list_push_front (&thread_current()->children, &child->elem);
+
+  t->fd_table = (struct file **) palloc_get_page(PAL_USER | PAL_ZERO);
+  if (t->fd_table == NULL){
+    free(child);
+    palloc_free_page(t);
+    return TID_ERROR;
+  }
+  
+  // Deny writes to currently executing file
+  if (strcmp("idle", name)){
+    t->fd_table[0] = filesys_open(name);
+    if (t->fd_table[0] != NULL)
+      file_deny_write(t->fd_table[0]);
+  }
+
   /* Add to run queue. */
   thread_unblock (t);
 
@@ -432,6 +461,9 @@
   old_level = intr_disable ();
   list_push_back (&all_list, &t->allelem);
   intr_set_level (old_level);
+
+  sema_init (&t->child_created, 0);
+  list_init (&t->children);
 }
 
 /* Allocates a SIZE-byte frame at the top of thread T's stack and
diff -ruN aos_pintos/src/threads/thread.h pintos-solution/src/threads/thread.h
--- aos_pintos/src/threads/thread.h	2024-02-09 02:53:00.333657240 +0000
+++ pintos-solution/src/threads/thread.h	2024-04-30 04:52:23.000000000 +0000
@@ -4,6 +4,7 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -95,11 +96,22 @@
   /* Shared between thread.c and synch.c. */
   struct list_elem elem; /* List element. */
 
+  struct thread* parent; // Pointer to parent thread
+  struct list children; // List of children threads & metadata
+
+  struct semaphore child_created; // Synchronize exec method
+  bool success; // Was exec successful 
+
+  struct file** fd_table; // Map fd (index) to files
+
 #ifdef USERPROG
   /* Owned by userprog/process.c. */
   uint32_t *pagedir; /* Page directory. */
 #endif
 
+   // P4 tryout:
+   // struct dir *cwd;
+
   /* Owned by thread.c. */
   unsigned magic; /* Detects stack overflow. */
 };
@@ -140,7 +152,4 @@
 int thread_get_recent_cpu (void);
 int thread_get_load_avg (void);
 
-bool less_tid(const struct list_elem *a, const struct list_elem *b, void *aux);  
-
-
 #endif /* threads/thread.h */
diff -ruN aos_pintos/src/userprog/exception.c pintos-solution/src/userprog/exception.c
--- aos_pintos/src/userprog/exception.c	2024-02-09 01:26:32.251944971 +0000
+++ pintos-solution/src/userprog/exception.c	2024-03-31 05:11:48.000000000 +0000
@@ -1,4 +1,5 @@
 #include "userprog/exception.h"
+#include "userprog/syscall.h"
 #include <inttypes.h>
 #include <stdio.h>
 #include "userprog/gdt.h"
@@ -140,15 +141,6 @@
   not_present = (f->error_code & PF_P) == 0;
   write = (f->error_code & PF_W) != 0;
   user = (f->error_code & PF_U) != 0;
-
-  /* To implement virtual memory, delete the rest of the function
-     body, and replace it with code that brings in the page to
-     which fault_addr refers. */
-  printf ("Page fault at %p: %s error %s page in %s context.\n", fault_addr,
-          not_present ? "not present" : "rights violation",
-          write ? "writing" : "reading", user ? "user" : "kernel");
-
-  printf ("There is no crying in Pintos!\n");
-
-  kill (f);
+  
+  exit(-1);
 }
diff -ruN aos_pintos/src/userprog/process.c pintos-solution/src/userprog/process.c
--- aos_pintos/src/userprog/process.c	2024-02-09 01:26:32.243945324 +0000
+++ pintos-solution/src/userprog/process.c	2024-03-31 05:11:48.000000000 +0000
@@ -8,6 +8,7 @@
 #include "userprog/gdt.h"
 #include "userprog/pagedir.h"
 #include "userprog/tss.h"
+#include "userprog/syscall.h"
 #include "filesys/directory.h"
 #include "filesys/file.h"
 #include "filesys/filesys.h"
@@ -15,11 +16,14 @@
 #include "threads/init.h"
 #include "threads/interrupt.h"
 #include "threads/palloc.h"
+#include "threads/malloc.h"
+#include "lib/string.h"
 #include "threads/thread.h"
 #include "threads/vaddr.h"
 
+#define ALIGN(ADDR) ((void *) ((uintptr_t) ADDR - (uintptr_t) ADDR % 4))
+
 static thread_func start_process NO_RETURN;
-static bool load (const char *cmdline, void (**eip) (void), void **esp);
 
 /* Starts a new thread running a user program loaded from
    FILENAME.  The new thread may be scheduled (and may even exit)
@@ -37,8 +41,16 @@
     return TID_ERROR;
   strlcpy (fn_copy, file_name, PGSIZE);
 
+  // Get executable name for thread create
+  char *save_ptr;
+  const char delimiter[7] = " \t\r\n\f\v";
+  int len = strlen (file_name);
+  char args_copy[len + 1];
+  strlcpy (args_copy, file_name, len + 1);
+  char *exec_name = strtok_r ((char *) args_copy, delimiter, &save_ptr);
+
   /* Create a new thread to execute FILE_NAME. */
-  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);
+  tid = thread_create (exec_name, PRI_DEFAULT, start_process, fn_copy);
   if (tid == TID_ERROR)
     palloc_free_page (fn_copy);
   return tid;
@@ -46,9 +58,8 @@
 
 /* A thread function that loads a user process and starts it
    running. */
-static void start_process (void *file_name_)
+static void start_process (void *filename)
 {
-  char *file_name = file_name_;
   struct intr_frame if_;
   bool success;
 
@@ -57,12 +68,20 @@
   if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
   if_.cs = SEL_UCSEG;
   if_.eflags = FLAG_IF | FLAG_MBS;
-  success = load (file_name, &if_.eip, &if_.esp);
+  success = load (filename, &if_.eip, &if_.esp);
+
+  if (!is_kernel_vaddr (filename))
+    palloc_free_page (filename);
+
+  thread_current ()->parent->success = success;
+  sema_up (&thread_current ()->parent->child_created);
 
   /* If load failed, quit. */
-  palloc_free_page (file_name);
+  palloc_free_page (filename);
   if (!success)
-    thread_exit ();
+    {
+      exit (-1);
+    }
 
   /* Start the user process by simulating a return from an
      interrupt, implemented by intr_exit (in
@@ -70,7 +89,7 @@
      arguments on the stack in the form of a `struct intr_frame',
      we just point the stack pointer (%esp) to our stack frame
      and jump to it. */
-  asm volatile("movl %0, %%esp; jmp intr_exit" : : "g"(&if_) : "memory");
+  asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g"(&if_) : "memory");
   NOT_REACHED ();
 }
 
@@ -83,7 +102,33 @@
 
    This function will be implemented in problem 2-2.  For now, it
    does nothing. */
-int process_wait (tid_t child_tid UNUSED) { return -1; }
+int process_wait (tid_t child_tid UNUSED)
+{
+  struct thread *parent = thread_current ();
+  struct list *children = &parent->children;
+
+  if (list_empty (children))
+    {
+      return -1;
+    }
+
+  // Find child if in children list and wait on its exit returning status
+  struct list_elem *curr;
+  for (curr = list_front (children); curr != list_end (children);
+       curr = list_next (curr))
+    {
+      struct child *curr_item = list_entry (curr, struct child, elem);
+      if (curr_item->pid == child_tid)
+        {
+          sema_down (&curr_item->exited);
+          list_remove (curr);
+          int status = curr_item->exit_status;
+          free (curr_item);
+          return status;
+        }
+    }
+  return -1;
+}
 
 /* Free the current process's resources. */
 void process_exit (void)
@@ -124,54 +169,6 @@
   tss_update ();
 }
 
-/* We load ELF binaries.  The following definitions are taken
-   from the ELF specification, [ELF1], more-or-less verbatim.  */
-
-/* ELF types.  See [ELF1] 1-2. */
-typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;
-typedef uint16_t Elf32_Half;
-
-/* For use with ELF types in printf(). */
-#define PE32Wx PRIx32 /* Print Elf32_Word in hexadecimal. */
-#define PE32Ax PRIx32 /* Print Elf32_Addr in hexadecimal. */
-#define PE32Ox PRIx32 /* Print Elf32_Off in hexadecimal. */
-#define PE32Hx PRIx16 /* Print Elf32_Half in hexadecimal. */
-
-/* Executable header.  See [ELF1] 1-4 to 1-8.
-   This appears at the very beginning of an ELF binary. */
-struct Elf32_Ehdr
-{
-  unsigned char e_ident[16];
-  Elf32_Half e_type;
-  Elf32_Half e_machine;
-  Elf32_Word e_version;
-  Elf32_Addr e_entry;
-  Elf32_Off e_phoff;
-  Elf32_Off e_shoff;
-  Elf32_Word e_flags;
-  Elf32_Half e_ehsize;
-  Elf32_Half e_phentsize;
-  Elf32_Half e_phnum;
-  Elf32_Half e_shentsize;
-  Elf32_Half e_shnum;
-  Elf32_Half e_shstrndx;
-};
-
-/* Program header.  See [ELF1] 2-2 to 2-4.
-   There are e_phnum of these, starting at file offset e_phoff
-   (see [ELF1] 1-6). */
-struct Elf32_Phdr
-{
-  Elf32_Word p_type;
-  Elf32_Off p_offset;
-  Elf32_Addr p_vaddr;
-  Elf32_Addr p_paddr;
-  Elf32_Word p_filesz;
-  Elf32_Word p_memsz;
-  Elf32_Word p_flags;
-  Elf32_Word p_align;
-};
-
 /* Values for p_type.  See [ELF1] 2-3. */
 #define PT_NULL 0           /* Ignore. */
 #define PT_LOAD 1           /* Loadable segment. */
@@ -187,7 +184,7 @@
 #define PF_W 2 /* Writable. */
 #define PF_R 4 /* Readable. */
 
-static bool setup_stack (void **esp);
+static bool setup_stack (void **esp, const char *filename);
 static bool validate_segment (const struct Elf32_Phdr *, struct file *);
 static bool load_segment (struct file *file, off_t ofs, uint8_t *upage,
                           uint32_t read_bytes, uint32_t zero_bytes,
@@ -197,14 +194,21 @@
    Stores the executable's entry point into *EIP
    and its initial stack pointer into *ESP.
    Returns true if successful, false otherwise. */
-bool load (const char *file_name, void (**eip) (void), void **esp)
+bool load (const char *args, void (**eip) (void), void **esp)
 {
   struct thread *t = thread_current ();
   struct Elf32_Ehdr ehdr;
   struct file *file = NULL;
   off_t file_ofs;
   bool success = false;
-  int i;
+  int argc;
+
+  char *save_ptr;
+  const char delimiter[7] = " \t\r\n\f\v";
+  int len = strlen (args);
+  char args_copy[len + 1];
+  strlcpy (args_copy, args, len + 1);
+  char *filename = strtok_r ((char *) args_copy, delimiter, &save_ptr);
 
   /* Allocate and activate page directory. */
   t->pagedir = pagedir_create ();
@@ -213,10 +217,10 @@
   process_activate ();
 
   /* Open executable file. */
-  file = filesys_open (file_name);
+  file = filesys_open (filename);
   if (file == NULL)
     {
-      printf ("load: %s: open failed\n", file_name);
+      printf ("load: %s: open failed\n", filename);
       goto done;
     }
 
@@ -226,13 +230,13 @@
       ehdr.e_machine != 3 || ehdr.e_version != 1 ||
       ehdr.e_phentsize != sizeof (struct Elf32_Phdr) || ehdr.e_phnum > 1024)
     {
-      printf ("load: %s: error loading executable\n", file_name);
+      printf ("load: %s: error loading executable\n", filename);
       goto done;
     }
 
   /* Read program headers. */
   file_ofs = ehdr.e_phoff;
-  for (i = 0; i < ehdr.e_phnum; i++)
+  for (argc = 0; argc < ehdr.e_phnum; argc++)
     {
       struct Elf32_Phdr phdr;
 
@@ -243,6 +247,9 @@
       if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
         goto done;
       file_ofs += sizeof phdr;
+      
+      // [placeholder] - it is turtles all the way down
+      
       switch (phdr.p_type)
         {
           case PT_NULL:
@@ -291,7 +298,7 @@
     }
 
   /* Set up stack. */
-  if (!setup_stack (esp))
+  if (!setup_stack (esp, args))
     goto done;
 
   /* Start address. */
@@ -412,21 +419,109 @@
   return true;
 }
 
+static bool decrement_stack (char **char_esp, void *stackpg, char **tokens,
+                             int d)
+{
+  *char_esp -= d;
+  bool valid_dec =
+      ((uintptr_t) *char_esp >= (uintptr_t) PHYS_BASE - (uintptr_t) PGSIZE);
+  if (!valid_dec)
+    {
+      palloc_free_page (tokens);
+      palloc_free_page (stackpg);
+    }
+  return valid_dec;
+}
+
 /* Create a minimal stack by mapping a zeroed page at the top of
    user virtual memory. */
-static bool setup_stack (void **esp)
+static bool setup_stack (void **esp, const char *filename)
 {
   uint8_t *kpage;
   bool success = false;
+  char *file_name = (char *) filename;
+
+  char **tokens = palloc_get_page (0);
+  if (tokens == NULL)
+    return false;
+  char *save_ptr;
+  const char delimiter[7] = " \t\r\n\f\v";
+  tokens[0] = strtok_r (file_name, delimiter, &save_ptr);
+  int argc = 0;
+  while (tokens[argc])
+    {
+      argc++;
+      if (argc > 128)
+        {
+          return false;
+        }
+      tokens[argc] = strtok_r (NULL, delimiter, &save_ptr);
+    }
 
   kpage = palloc_get_page (PAL_USER | PAL_ZERO);
   if (kpage != NULL)
     {
       success = install_page (((uint8_t *) PHYS_BASE) - PGSIZE, kpage, true);
       if (success)
-        *esp = PHYS_BASE;
+        {
+          *esp = PHYS_BASE;
+          char *char_esp = (char *) *esp;
+          int i = argc - 1;
+          while (i >= 0)
+            {
+              int len = strlen (tokens[i]) + 1;
+              if (!decrement_stack (&char_esp, kpage, tokens, len))
+                {
+                  return false;
+                }
+              memcpy (char_esp, tokens[i], len);
+              i--;
+            }
+
+          char_esp = ALIGN (char_esp); // align down to nearest multiple of 4
+
+          if (!decrement_stack (&char_esp, kpage, tokens, 4))
+            {
+              return false;
+            }
+          int *arg_end = (int *) char_esp;
+          *arg_end = 0;
+
+          i = argc - 1;
+          char *top = *esp;
+          while (i >= 0)
+            {
+              if (!decrement_stack (&char_esp, kpage, tokens, 4))
+                {
+                  return false;
+                }
+              top -= strlen (tokens[i]) + 1;
+              memcpy (char_esp, &top, 4);
+              i--;
+            }
+          char *arg_start = char_esp;
+          if (!decrement_stack (&char_esp, kpage, tokens, 4))
+            {
+              return false;
+            }
+          memcpy (char_esp, &arg_start, 4);
+          if (!decrement_stack (&char_esp, kpage, tokens, 4))
+            {
+              return false;
+            }
+          memcpy (char_esp, &argc, 4);
+          if (!decrement_stack (&char_esp, kpage, tokens, 4))
+            {
+              return false;
+            }
+          *esp = char_esp;
+          palloc_free_page (tokens);
+        }
       else
-        palloc_free_page (kpage);
+        {
+          palloc_free_page (tokens);
+          palloc_free_page (kpage);
+        }
     }
   return success;
 }
diff -ruN aos_pintos/src/userprog/process.h pintos-solution/src/userprog/process.h
--- aos_pintos/src/userprog/process.h	2024-02-09 01:26:32.259944619 +0000
+++ pintos-solution/src/userprog/process.h	2024-03-31 05:11:50.000000000 +0000
@@ -2,7 +2,67 @@
 #define USERPROG_PROCESS_H
 
 #include "threads/thread.h"
+#include "lib/kernel/list.h"
+#include "threads/synch.h"
 
+struct child
+{
+   struct thread* child_thread;
+   struct list_elem elem;
+   struct semaphore exited;
+   int pid;
+   int exit_status;
+};
+
+/* We load ELF binaries.  The following definitions are taken
+   from the ELF specification, [ELF1], more-or-less verbatim.  */
+
+/* ELF types.  See [ELF1] 1-2. */
+typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;
+typedef uint16_t Elf32_Half;
+
+/* For use with ELF types in printf(). */
+#define PE32Wx PRIx32 /* Print Elf32_Word in hexadecimal. */
+#define PE32Ax PRIx32 /* Print Elf32_Addr in hexadecimal. */
+#define PE32Ox PRIx32 /* Print Elf32_Off in hexadecimal. */
+#define PE32Hx PRIx16 /* Print Elf32_Half in hexadecimal. */
+
+/* Executable header.  See [ELF1] 1-4 to 1-8.
+   This appears at the very beginning of an ELF binary. */
+struct Elf32_Ehdr
+{
+  unsigned char e_ident[16];
+  Elf32_Half e_type;
+  Elf32_Half e_machine;
+  Elf32_Word e_version;
+  Elf32_Addr e_entry;
+  Elf32_Off e_phoff;
+  Elf32_Off e_shoff;
+  Elf32_Word e_flags;
+  Elf32_Half e_ehsize;
+  Elf32_Half e_phentsize;
+  Elf32_Half e_phnum;
+  Elf32_Half e_shentsize;
+  Elf32_Half e_shnum;
+  Elf32_Half e_shstrndx;
+};
+
+/* Program header.  See [ELF1] 2-2 to 2-4.
+   There are e_phnum of these, starting at file offset e_phoff
+   (see [ELF1] 1-6). */
+struct Elf32_Phdr
+{
+  Elf32_Word p_type;
+  Elf32_Off p_offset;
+  Elf32_Addr p_vaddr;
+  Elf32_Addr p_paddr;
+  Elf32_Word p_filesz;
+  Elf32_Word p_memsz;
+  Elf32_Word p_flags;
+  Elf32_Word p_align;
+};
+
+bool load (const char *cmdline, void (**eip) (void), void **esp);
 tid_t process_execute (const char *file_name);
 int process_wait (tid_t);
 void process_exit (void);
diff -ruN aos_pintos/src/userprog/syscall.c pintos-solution/src/userprog/syscall.c
--- aos_pintos/src/userprog/syscall.c	2024-02-09 01:26:32.255944795 +0000
+++ pintos-solution/src/userprog/syscall.c	2024-04-30 04:51:58.000000000 +0000
@@ -1,19 +1,670 @@
 #include "userprog/syscall.h"
+#include "userprog/pagedir.h"
 #include <stdio.h>
 #include <syscall-nr.h>
-#include "devices/block.h"
 #include "threads/interrupt.h"
 #include "threads/thread.h"
+#include "threads/vaddr.h"
+#include "threads/malloc.h"
+#include "threads/synch.h"
+#include "userprog/process.h"
+#include "devices/shutdown.h"
+#include "threads/palloc.h"
+#include "threads/malloc.h"
+#include "lib/kernel/stdio.h"
+#include "lib/stdio.h"
+#include "lib/string.h"
+#include "filesys/filesys.h"
+#include "filesys/file.h"
+#include "filesys/inode.h"
+#include "userprog/gdt.h"
+#include "threads/flags.h"
+#include "devices/input.h"
+#include "devices/block.h"
 
+// P2 solution:
 static void syscall_handler (struct intr_frame *);
+static bool valid_ptr (void *);
+
+static struct semaphore filesys_mutex; // Ensure mutual exclusion to filesys
+
+const int MAX_OPEN_FILES = 1024; // Max open files per process
 
 void syscall_init (void)
 {
   intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
+  sema_init (&filesys_mutex, 1);
+}
+
+/* Check if pointers to arguments are valid */
+static int check_args (void *esp, int num_args)
+{
+  int *int_esp = (int *) esp;
+  for (int i = 0; i < num_args; i++)
+    {
+      int_esp += 1;
+      if (!valid_ptr (int_esp))
+        {
+          return 1;
+        }
+    }
+  return 0;
 }
 
 static void syscall_handler (struct intr_frame *f UNUSED)
 {
-  printf ("system call!\n");
+  if (!valid_ptr (f->esp))
+    {
+      exit (-1);
+    }
+  int syscall_num = *(int *) f->esp;
+
+  switch (syscall_num)
+    {
+      case SYS_HALT:
+        halt ();
+        break;
+      case SYS_EXIT:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        int status = *((int *) f->esp + 1);
+        exit (status);
+        break;
+      case SYS_EXEC:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        char *filename = *((char **) f->esp + 1);
+        f->eax = exec (filename);
+        break;
+      case SYS_WAIT:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        pid_t pid = *((pid_t *) f->esp + 1);
+        f->eax = wait (pid);
+        break;
+      case SYS_CREATE:
+        if (check_args (f->esp, 3))
+          {
+            exit (-1);
+          }
+        void *file_c = *((char **) f->esp + 1);
+        unsigned initial_size = *((int *) f->esp + 2);
+        f->eax = create (file_c, initial_size);
+        break;
+      case SYS_REMOVE:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        void *file_r = *((char **) f->esp + 1);
+        f->eax = remove (file_r);
+        break;
+      case SYS_OPEN:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        char *file_o = *((char **) f->esp + 1);
+        f->eax = open (file_o);
+        break;
+      case SYS_FILESIZE:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        unsigned fd_f = *((int *) f->esp + 1);
+        f->eax = filesize (fd_f);
+        break;
+      case SYS_READ:
+        if (check_args (f->esp, 3))
+          {
+            exit (-1);
+          }
+        int fd_r = *((int *) f->esp + 1);
+        void *buffer_r = *((char **) f->esp + 2);
+        unsigned size_r = *((int *) f->esp + 3);
+        f->eax = read (fd_r, buffer_r, size_r);
+        break;
+      case SYS_WRITE:
+        if (check_args (f->esp, 3))
+          {
+            exit (-1);
+          }
+        int fd_w = *((int *) f->esp + 1);
+        void *buffer_w = *((char **) f->esp + 2);
+        unsigned size_w = *((int *) f->esp + 3);
+        f->eax = write (fd_w, buffer_w, size_w);
+        break;
+      case SYS_SEEK:
+        if (check_args (f->esp, 2))
+          {
+            exit (-1);
+          }
+        int fd_s = *((int *) f->esp + 1);
+        unsigned position = *((unsigned *) f->esp + 2);
+        seek (fd_s, position);
+        break;
+      case SYS_TELL:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        int fd_t = *((int *) f->esp + 1);
+        f->eax = tell (fd_t);
+        break;
+      case SYS_CLOSE:
+        if (check_args (f->esp, 1))
+          {
+            exit (-1);
+          }
+        int fd_c = *((int *) f->esp + 1);
+        close (fd_c);
+        break;
+      case SYS_SYMLINK:
+        if (check_args (f->esp, 2))
+          {
+            exit (-1);
+          }
+        char *target = *((char **) f->esp + 1);
+        char *linkpath = *((char **) f->esp + 2);
+        f->eax = symlink (target, linkpath);
+        break;
+      
+      // P4 tryout:
+      case SYS_CHDIR: // 15
+      if (check_args (f->esp, 1)) {
+        exit (-1);
+      }
+      char *file_cd = *((char **) f->esp + 1);
+      f->eax = chdir (file_cd);
+      break;
+
+    case SYS_MKDIR: // 16
+      if (check_args (f->esp, 1)) {
+        exit (-1);
+      }
+      char *file_m = *((char **) f->esp + 1);
+      f->eax = mkdir (file_m);
+      break;
+
+    case SYS_READDIR: // 17
+      if (check_args (f->esp, 2)) {
+        exit (-1);
+      }
+      int fd_rd = *((int *) f->esp + 1);
+      char *name = *((char **) f->esp + 2);
+      f->eax = readdir (fd_rd, name);
+      break;
+
+    case SYS_ISDIR: // 18
+      if (check_args (f->esp, 1)){
+        exit (-1);
+      }
+      int fd_is = *((int *) f->esp + 1);
+      f->eax = isdir (fd_is);
+      break;
+
+    case SYS_INUMBER: // 19
+      if (check_args (f->esp, 1)){
+        exit (-1);
+      }
+      int fd_in = *((int *) f->esp + 1);
+      f->eax = inumber (fd_in);
+      break;
+    
+    case SYS_STAT:
+      if (check_args (f->esp, 2)) {
+        exit (-1);
+      }
+      char *pathname = *((char **) f->esp + 1);
+      void *buffer_s = *((char **) f->esp + 2);
+      f->eax = stat (pathname, buffer_s);
+      break;
+    }
+}
+
+void halt () { shutdown_power_off (); }
+
+void exit (int status)
+{
+  printf ("%s: exit(%d)\n", thread_current ()->name, status);
+
+  // Free all of exiting thread's children
+  struct list *our_children = &(thread_current ()->children);
+  if (!list_empty (our_children))
+    {
+      struct list_elem *curr;
+      for (curr = list_front (our_children); curr != list_end (our_children);)
+        {
+          struct child *curr_item = list_entry (curr, struct child, elem);
+          curr_item->child_thread->parent = NULL;
+          curr = curr->next;
+          free (curr_item);
+        }
+    }
+
+  // Close all open files
+  int fd = 2;
+  struct file **fds = thread_current ()->fd_table;
+  while (fd < MAX_OPEN_FILES)
+    {
+      if (fds[fd] != NULL)
+        {
+          close (fd);
+        }
+      fd++;
+    }
+
+  /* Find current thread in parents children data structure and communicate exit
+  status */
+  if (thread_current ()->parent)
+    {
+      struct list *children = &(thread_current ()->parent->children);
+      if (!list_empty (children))
+        {
+          struct list_elem *curr;
+          struct child *curr_item;
+          for (curr = list_front (children); curr != list_end (children);
+               curr = list_next (curr))
+            {
+              curr_item = list_entry (curr, struct child, elem);
+              if (curr_item->pid == thread_current ()->tid)
+                {
+                  curr_item->exit_status = status;
+                  // Let waiting parent know you are finished
+                  sema_up (&curr_item->exited);
+                  break;
+                }
+            }
+        }
+    }
+  // Re-enable writes to executable associated w/ this process
+  close (0);
+  palloc_free_page (thread_current ()->fd_table);
   thread_exit ();
-}
\ No newline at end of file
+}
+
+pid_t exec (const char *cmd_line)
+{
+  if (!valid_ptr ((void *) cmd_line))
+    {
+      exit (-1);
+    }
+
+  int tid = process_execute (cmd_line);
+
+  sema_down (&thread_current ()->child_created); // wait for child creation
+  tid = !thread_current ()->success ? -1 : tid;  // if exec fails tid = -1
+  thread_current ()->success = false;            // reset success value
+  return tid;
+}
+
+int wait (pid_t pid) { return process_wait (pid); }
+
+bool create (const char *file, unsigned initial_size)
+{
+  if (!valid_ptr ((void *) file))
+    {
+      exit (-1);
+    }
+
+  sema_down (&filesys_mutex);
+  bool opened = filesys_create (file, initial_size);
+  sema_up (&filesys_mutex);
+
+  return opened;
+}
+
+bool remove (const char *file)
+{
+  if (!valid_ptr ((void *) file))
+    {
+      exit (-1);
+    }
+  sema_down (&filesys_mutex);
+  bool removed = filesys_remove (file);
+  sema_up (&filesys_mutex);
+  return removed;
+}
+
+int open (const char *filename)
+{
+  if (!valid_ptr ((void *) filename))
+    {
+      exit (-1);
+    }
+
+  struct file **fds = thread_current ()->fd_table;
+  int fd = 2;
+  struct file *curr = fds[fd];
+
+  // Find open spot in table to open file
+  while (curr != NULL)
+    {
+      curr = fds[++fd];
+      if (fd == MAX_OPEN_FILES)
+        {
+          return -1;
+        }
+    }
+
+  sema_down (&filesys_mutex);
+  struct file *file = filesys_open (filename);
+  sema_up (&filesys_mutex);
+  if (file == NULL)
+    {
+      return -1;
+    }
+
+  fds[fd] = file;
+  return fd;
+}
+
+int filesize (int fd)
+{
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL)
+    {
+      return 0;
+    }
+  sema_down (&filesys_mutex);
+  int length = file_length (file);
+  sema_up (&filesys_mutex);
+  return length;
+}
+
+int read (int fd, void *buffer, unsigned size)
+{
+  if (fd >= MAX_OPEN_FILES || fd == 1 || fd < 0)
+    {
+      return -1;
+    }
+  if (!valid_ptr ((void *) buffer) || !valid_ptr ((char *) buffer + size))
+    {
+      exit (-1);
+    }
+
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL)
+    {
+      return 0;
+    }
+  unsigned bytes_read = 0;
+
+  // Read from stdin
+  if (fd == 0)
+    {
+      for (unsigned i = 0; i < size; i++)
+        {
+          *((char *) buffer + i) = input_getc ();
+          bytes_read++;
+        }
+    }
+  else // Read from file
+    {
+      sema_down (&filesys_mutex);
+      bytes_read = file_read (file, buffer, size);
+      sema_up (&filesys_mutex);
+    }
+
+  return bytes_read;
+}
+
+int write (int fd, const void *buffer, unsigned size)
+{
+  if (!valid_ptr ((void *) buffer) || !valid_ptr ((char *) buffer + size))
+    {
+      exit (-1);
+    }
+  if (fd >= MAX_OPEN_FILES || fd <= 0)
+    {
+      return 0;
+    }
+  if (fd == 1) // Write to stdout
+    {
+      putbuf (((char *) buffer), (size_t) size);
+      return size;
+    }
+
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL || file->deny_write)
+    {
+      return 0;
+    }
+
+  sema_down (&filesys_mutex);
+  unsigned bytes_written = file_write (file, buffer, size);
+  sema_up (&filesys_mutex);
+  return bytes_written;
+}
+
+void seek (int fd, unsigned position)
+{
+  if (fd >= MAX_OPEN_FILES || fd == 1)
+    {
+      return;
+    }
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL)
+    {
+      return;
+    }
+  sema_down (&filesys_mutex);
+  file_seek (file, position);
+  sema_up (&filesys_mutex);
+}
+
+unsigned tell (int fd)
+{
+  if (fd >= MAX_OPEN_FILES)
+    {
+      return 0;
+    }
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL)
+    {
+      return 0;
+    }
+  sema_down (&filesys_mutex);
+  unsigned pos = file_tell (file);
+  sema_up (&filesys_mutex);
+  return pos;
+}
+
+void close (int fd)
+{
+  struct file **fds = thread_current ()->fd_table;
+  if (fd >= MAX_OPEN_FILES)
+    {
+      return;
+    }
+  sema_down (&filesys_mutex);
+  file_close (fds[fd]);
+  fds[fd] = NULL;
+  sema_up (&filesys_mutex);
+}
+
+int symlink (char *target, char *linkpath)
+{
+  sema_down (&filesys_mutex);
+  struct file *target_file = filesys_open (target);
+  sema_up (&filesys_mutex);
+
+  if (target_file == NULL)
+    {
+      return -1;
+    }
+
+  sema_down (&filesys_mutex);
+  bool success = filesys_symlink (target, linkpath);
+  sema_up (&filesys_mutex);
+
+  return success ? 0 : -1;
+}
+
+bool valid_ptr (void *ptr)
+{
+  return ptr && !is_kernel_vaddr (ptr) &&
+         pagedir_get_page (thread_current ()->pagedir, ptr);
+}
+
+
+// P4 tryout:
+/* System Call: bool chdir (const char *dir) */
+bool chdir (const char *dir)
+{
+  if (!valid_ptr ((void *) dir)) {
+    return false;
+  }
+
+  // sema_down (&filesys_mutex);
+  // bool ret = filesys_chdir (dir);
+  // // if (directory == NULL) {
+  // //   sema_up (&filesys_mutex);
+  // //   return false;
+  // // }
+
+  // // struct thread *cur = thread_current ();
+  // // dir_close (cur->cwd);  // Close the current working directory
+  // // cur->cwd = directory;  // Update the current working directory
+  // sema_up (&filesys_mutex);
+
+  return true;
+}
+
+/* System Call: bool mkdir (const char *dir) */
+bool mkdir (const char *dir)
+{
+  if (!valid_ptr ((void *) dir)) {
+    return false;
+  }
+  
+  // sema_down (&filesys_mutex);
+  // bool ret = filesys_create (dir, 0, true);
+  // sema_up (&filesys_mutex);
+
+  return true;
+}
+
+/* System Call: bool readdir (int fd, char *name) */
+bool readdir (int fd, char *name)
+{
+  if (fd < 3 || fd >= MAX_OPEN_FILES || name == NULL || !valid_ptr (name)) {
+    return false;
+  }
+
+  sema_down (&filesys_mutex);
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL) {
+    sema_up (&filesys_mutex);
+    return false;
+  }
+
+  // struct inode *inode = file_get_inode(file);
+  // if(inode == NULL) {
+  //   sema_up (&filesys_mutex);
+  //   return false;
+  // }
+
+  // if(! inode_is_dir(inode)) {
+  //   sema_up (&filesys_mutex);
+  //   return false;
+  // }
+
+  // struct dir *dir = dir_open (inode);
+  // if (dir == NULL) {
+  //   sema_up (&filesys_mutex);
+  //   return false;
+  // }
+
+  // bool success = dir_readdir (dir, name);
+  // // dir_close (dir);
+  sema_up (&filesys_mutex);
+
+  return true;
+}
+
+/* System Call: bool isdir (int fd) */
+bool isdir (int fd)
+{
+  if (fd < 3 || fd >= MAX_OPEN_FILES) {
+    return false;
+  }
+
+  sema_down (&filesys_mutex);
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL) {
+    sema_up (&filesys_mutex);
+    return false;
+  }
+  
+  // bool ret = inode_is_dir (file_get_inode (file));
+  sema_up (&filesys_mutex);
+
+  return true;
+}
+
+/* System Call: int inumber (int fd) */
+int inumber (int fd)
+{
+  if (fd < 3 || fd >= MAX_OPEN_FILES) {
+    return -1;
+  }
+
+  sema_down (&filesys_mutex);
+  struct file *file = thread_current ()->fd_table[fd];
+  if (file == NULL) {
+    sema_up (&filesys_mutex);
+    return -1;
+  }
+  
+  // int ret = (int) inode_get_inumber (file_get_inode (file));
+  sema_up (&filesys_mutex);
+
+  return 0;
+}
+
+/* System Call: int stat (char *pathname, void *buf) */
+int stat(const char *pathname, void *buf)
+{
+    struct stat *stat_buf;
+    struct inode *inode;
+    int result = -1; // Default error return value
+
+    /* Check if the buffer pointer is valid */
+    if (!valid_ptr ((void *) buf) || !valid_ptr ((char *) buf + sizeof(struct stat))) {
+        return -1;
+    }
+
+    /* Allocate memory for the stat structure */
+    sema_down (&filesys_mutex);
+    stat_buf = (struct stat *)malloc(sizeof(struct stat));
+    if (stat_buf == NULL) {
+        sema_up (&filesys_mutex);
+        return -1; // Memory allocation failed
+    }
+
+    /* Open the inode corresponding to the pathname */
+    // inode = filesys_open_inode(pathname);
+    // if (inode != NULL)
+    // {
+    //     /* Fill the stat structure with inode information */
+    //     stat_buf->logical_size = inode_length(inode);
+    //     stat_buf->physical_size = inode_length_physical(inode);
+    //     stat_buf->inode_number = inode_get_inumber(inode);
+    //     stat_buf->blocks = inode_get_blocks(inode);
+
+    //     /* Copy the stat structure to the user-provided buffer */
+    //     memcpy(buf, stat_buf, sizeof(struct stat));
+    // }
+
+    free(stat_buf); // Free allocated memory
+    sema_up (&filesys_mutex);
+    return result;
+}
diff -ruN aos_pintos/src/userprog/syscall.h pintos-solution/src/userprog/syscall.h
--- aos_pintos/src/userprog/syscall.h	2024-02-09 01:26:32.263944443 +0000
+++ pintos-solution/src/userprog/syscall.h	2024-04-30 04:48:45.000000000 +0000
@@ -3,6 +3,28 @@
 
 #include <stdbool.h>
 
+typedef int pid_t;
 void syscall_init (void);
+void halt (void);
+void exit (int);
+pid_t exec (const char *);
+int wait (pid_t);
+bool create (const char *, unsigned);
+bool remove (const char *);
+int open (const char *);
+int filesize (int);
+int read (int, void *, unsigned);
+int write (int, const void *, unsigned);
+void seek (int, unsigned);
+unsigned tell (int);
+void close (int);
+int symlink (char *, char *);
+
+bool chdir (const char *dir);
+bool mkdir (const char *dir);
+bool readdir (int fd, char *name);
+bool isdir (int fd);
+int inumber (int fd);
+int stat (const char *pathname, void *buf);
 
 #endif /* userprog/syscall.h */
